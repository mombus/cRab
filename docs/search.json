[
  {
    "objectID": "chapter19.html",
    "href": "chapter19.html",
    "title": "20  II. DLM: CATCH-ONLY METHODS (COM)",
    "section": "",
    "text": "20.1 Введение\nНастоящее занятие посвящено методам оценки запасов водных биоресурсов при ограниченных данных Data-Limited Methods (DLM) подраздел Catch-only (есть только уловы) — инструментам, которые позволяют принимать управленческие решения даже тогда, когда почти вся информация о популяции недоступна. Если предыдущие занятия фокусировались на анализе полных данных съемок и промысла, то здесь мы обращаемся к реальности многих регионов и видов: у нас есть лишь временные ряды уловов, отрывочные сведения о биологии и, возможно, экспертные оценки. DLM-методы — это не «упрощенные версии» сложных моделей, а самостоятельный класс подходов, основанных на робастных принципах, предосторожности и явных допущениях.\nКак отмечал Нассим Талеб, уязвимость системы часто скрывается в её зависимости от точных данных там, где возможна лишь устойчивая оценка. DLM-методы предлагают философию «антихрупкости»: они признают неопределенность,оценивают её и встраивают в процесс принятия решений. В этом их ключевое отличие от «полноформатных» моделей вроде SS3 или SAM, которые требуют детальных данных, но могут давать иллюзию точности там, где её нет.\nПознакомимся с классификации DLM-методов по системе Tier* — иерархии, основанной на объеме доступных данных. На нижней ступени (Tier 0) находятся методы, опирающиеся лишь на аналогии и экспертные оценки; на верхней (Tier 4) — комбинированные подходы, интегрирующие данные уловов, индексы численности и размерную структуру. Посередине — ключевые для практики методы, которые мы разберем детально: Catch-MSY (CMSY), Depletion-Based SRA (DB-SRA), DCAC и другие. Каждый из них решает конкретный вопрос: как оценить MSY и текущее состояние запаса, если у нас есть только история уловов? Как учесть истощение? Как связать темп роста популяции с её устойчивостью?\nПрактическая часть занятия построена вокруг скрипта, который шаг за шагом проводит анализ по данным демонстрационного запаса. Вы увидите, как:\nОсобое внимание уделим взгляду на допущения: почему выбор априорных диапазонов для r (внутреннего темпа роста) так важен? Как тренды в уловах влияют на оценку истощения? Что делать, если методы дают противоречивые результаты? Мы будем использовать байесовский подход там, где он уместен (CMSY), и частотный там, где он прозрачнее (DB-SRA), всегда оговаривая ограничения.\nВ результате вы получите не просто набор кода, а framework для работы с данными в условиях их недостатка: от первичной диагностики временного ряда уловов до принятия решений о допустимом изъятии. Эти навыки критически важны для работы с новыми объектами промысла, восстановлением запасов или в регионах с ограниченным мониторингом.\nКак и в предыдущих занятиях, мы будем сочетать статистическую строгость с биологической интерпретацией. Помните: DLM-методы — это не «костыли», а «ходунки»: они позволяют сделать первые шаги к устойчивому управлению даже там, где данных мало, но решения принимать необходимо.\nФайл скрипта находиться здесь.\n* _Система Tier (уровней данных):\nTier 0: Нет количественных данных → Экспертные оценки, аналогии с другими запасами\nTier 1: Только уловы (Catch-Only) → CMSY, OCOM, DB-SRA, SSS\nTier 2: Уловы + индекс биомассы (CPUE/Survey) → DCAC, SPiCT, Простые продукционные модели\nTier 3: Уловы + размерная/возрастная структура → LBB, LBSPR, LIME, Mean-length методы\nTier 4: Комбинация данных (уловы + индексы + структура) → SS-CL, LIME с индексом, a4a\nTier 5: Полные данные → Stock Synthesis, VPA, SAM (не DLM)\n# ===============================================================\n#     ЗАНЯТИЕ 3: CATCH-ONLY METHODS (COM)\n#     Методы оценки запаса только по данным уловов\n#     Курс: Оценка водных биоресурсов при недостатке данных в R\n#     Обновлено: использование DLMtool вместо datalimited2\n# ===============================================================\n\n# ======================= ПОДГОТОВКА ==========================\n\n# Очистка рабочей среды\nrm(list = ls())\n\n# Установка и загрузка пакетов\n# Функция для установки если отсутствует\ninstall_if_missing &lt;- function(pkg) {\n  if (!require(pkg, character.only = TRUE)) {\n    install.packages(pkg)\n    library(pkg, character.only = TRUE)\n  }\n}\n\n# Установка основных пакетов\ncat(\"\\n========== УСТАНОВКА И ЗАГРУЗКА ПАКЕТОВ ==========\\n\")\n\n# DLMtool - основной пакет для DLM\n# install_if_missing(\"DLMtool\")  # Раскомментируйте при необходимости\n\n# Для CMSY метода устанавливаем отдельно\n# install.packages(\"remotes\")\n# remotes::install_github(\"SISTA16/cmsy\")  # Раскомментируйте для установки\n\n# Загрузка библиотек\n# Загрузка библиотек\nlibrary(DLMtool)       # Основной пакет для DLM методов\nlibrary(ggplot2)       # Визуализация\nlibrary(tidyverse)     # Обработка данных\nlibrary(gridExtra)     # Компоновка графиков\nlibrary(viridis)       # Цветовые схемы\n\n# Установка seed для воспроизводимости\nset.seed(42)\n\n# Отключение предупреждений DLMtool (опционально)\noptions(DLMtool.silent = TRUE)\n\n# ======================= ИСХОДНЫЕ ДАННЫЕ =======================\n\ncat(\"\\n========== ИСХОДНЫЕ ДАННЫЕ ==========\\n\")\n\n# Вектор лет наблюдений\nYear &lt;- 2005:2024\nnyears &lt;- length(Year)\n\n# Данные по вылову (тыс. тонн)\nCatch &lt;- c(5, 7, 6, 10, 14, 25, 28, 30, 32, 35, \n          25, 20, 15, 12, 10, 12, 10, 13, 11, 12)\n\n# Создание датафрейма для удобства\ncatch_df &lt;- data.frame(\n  Year = Year,\n  Catch = Catch\n)\n\n# Базовая статистика\ncat(\"\\nОсновная статистика уловов:\\n\")\ncat(sprintf(\"Период: %d - %d (%d лет)\\n\", min(Year), max(Year), nyears))\ncat(sprintf(\"Средний улов: %.1f тыс. т\\n\", mean(Catch)))\ncat(sprintf(\"Максимальный улов: %.1f тыс. т (%d год)\\n\", \n            max(Catch), Year[which.max(Catch)]))\ncat(sprintf(\"Минимальный улов: %.1f тыс. т (%d год)\\n\", \n            min(Catch), Year[which.min(Catch)]))\ncat(sprintf(\"Коэффициент вариации: %.2f\\n\", sd(Catch)/mean(Catch)))\n\n# Анализ тренда\nrecent_trend &lt;- mean(tail(Catch, 5)) / mean(head(Catch, 5))\ncat(sprintf(\"Изменение за период: %.0f%%\\n\", (recent_trend - 1) * 100))\n\n# ======================= ВИЗУАЛИЗАЦИЯ ИСХОДНЫХ ДАННЫХ =======================\n\n# График временного ряда с анализом\np1 &lt;- ggplot(catch_df, aes(x = Year, y = Catch)) +\n  # Основные данные\n  geom_line(linewidth = 1.2, color = \"darkblue\") +\n  geom_point(size = 3, color = \"darkblue\") +\n  \n  # Скользящее среднее (3 года)\n  geom_smooth(method = \"loess\", span = 0.3, se = TRUE, \n              alpha = 0.2, linewidth = 1, color = \"red\") +\n  \n  # Средний уровень\n  geom_hline(yintercept = mean(Catch), \n             linetype = \"dashed\", color = \"gray50\") +\n  \n  # Аннотации\n  annotate(\"text\", x = min(Year), y = mean(Catch), \n           label = \"Средний улов\", vjust = -0.5, hjust = 0, size = 3) +\n  \n  # Оформление\n  labs(title = \"Временной ряд уловов\",\n       subtitle = \"Исходные данные для catch-only анализа\",\n       x = \"Год\", y = \"Улов (тыс. т)\") +\n  theme_minimal() +\n  theme(plot.title = element_text(size = 14, face = \"bold\"))\n\nprint(p1)\n# ==================\n# ======================= СОЗДАНИЕ ОБЪЕКТОВ DLMtool =======================\n\ncat(\"\\n========== СОЗДАНИЕ ОБЪЕКТОВ DLMtool ==========\\n\")\n\n# DLMtool требует специальную структуру данных\n# Создаем объект Data_object с минимальной информацией\n\n## 1. Создание объекта Data\nCatchOnly_Data &lt;- new(\"Data\")\n\n# Основные параметры\nCatchOnly_Data@Name &lt;- \"Demo Stock\"\nCatchOnly_Data@Common_Name &lt;- \"Демерсальная рыба\"\nCatchOnly_Data@Year &lt;- as.numeric(Year)  # Важно: числовой вектор\nCatchOnly_Data@Cat &lt;- matrix(Catch, nrow = 1)  # Матрица уловов\nCatchOnly_Data@Units &lt;- \"тыс. тонн\"\nCatchOnly_Data@nareas &lt;- 1  # Количество районов\n\n# Добавляем минимальную биологическую информацию\n# Эти параметры типичны для демерсальной рыбы средней продолжительности жизни\nCatchOnly_Data@Mort &lt;- 0.2         # Естественная смертность (M)\nCatchOnly_Data@CV_Mort &lt;- 0.2      # CV для M\nCatchOnly_Data@vbK &lt;- 0.15         # Параметр роста фон Берталанфи K\nCatchOnly_Data@CV_vbK &lt;- 0.2       # CV для K\nCatchOnly_Data@vbLinf &lt;- 100       # Асимптотическая длина (см)\nCatchOnly_Data@CV_vbLinf &lt;- 0.1    # CV для Linf\nCatchOnly_Data@vbt0 &lt;- -0.5        # t0 в уравнении роста\nCatchOnly_Data@CV_vbt0 &lt;- 0.2      # CV для t0\nCatchOnly_Data@wla &lt;- 0.00001      # Параметр a в соотношении длина-вес\nCatchOnly_Data@wlb &lt;- 3.0          # Параметр b в соотношении длина-вес\nCatchOnly_Data@MaxAge &lt;- 20        # Максимальный возраст\nCatchOnly_Data@BMSY_B0 &lt;- 0.5      # Отношение BMSY/B0\n\n# Априорная информация о состоянии запаса\nCatchOnly_Data@Dep &lt;- 0.3          # Текущее истощение (B/B0) - экспертная оценка\nCatchOnly_Data@CV_Dep &lt;- 0.5       # Высокая неопределенность\n\n# Информация о промысле\nCatchOnly_Data@AvC &lt;- mean(Catch)  # Средний исторический улов\nCatchOnly_Data@CV_Cat &lt;- matrix(0.1, nrow = 1, ncol = length(Catch))  # CV уловов\n\n# Важные дополнительные параметры для DCAC\nCatchOnly_Data@LHYear &lt;- max(Year)  # Год, к которому относятся биологические параметры\nCatchOnly_Data@FMSY_M &lt;- 0.8        # Отношение FMSY/M (типичное значение)\nCatchOnly_Data@CV_FMSY_M &lt;- 0.2     # CV для FMSY/M\n\ncat(\"✓ Объект Data создан успешно\\n\")\ncat(sprintf(\"  Название запаса: %s\\n\", CatchOnly_Data@Name))\ncat(sprintf(\"  Период данных: %d - %d\\n\", min(Year), max(Year)))\ncat(sprintf(\"  Средний улов: %.1f %s\\n\", CatchOnly_Data@AvC, CatchOnly_Data@Units))\n\n# ======================= МЕТОД 1: DCAC (Depletion-Corrected Average Catch) =======================\n\ncat(\"\\n========== МЕТОД DCAC ==========\\n\")\ncat(\"Depletion-Corrected Average Catch\\n\")\ncat(\"Простейший catch-only метод с коррекцией на истощение\\n\\n\")\n\n# DCAC - встроенный метод в DLMtool\nDCAC_results &lt;- DCAC(\n  x = 1,                          # Индекс симуляции\n  Data = CatchOnly_Data,          # Объект данных\n  reps = 1000                     # Количество репликаций\n)\n\n\n# Детальный расчет DCAC для понимания\nDCAC_manual &lt;- function(catches, depletion, M = 0.2) {\n  # DCAC = средний улов * коррекция на истощение\n  avg_catch &lt;- mean(catches)\n  \n  # Коррекция зависит от истощения и M\n  if (depletion &lt; 0.5) {\n    correction &lt;- depletion * (1 + M)\n  } else {\n    correction &lt;- 1.0\n  }\n  \n  dcac_tac &lt;- avg_catch * correction\n  \n  return(list(\n    avg_catch = avg_catch,\n    depletion = depletion,\n    correction = correction,\n    tac = dcac_tac\n  ))\n}\n\ndcac_manual_result &lt;- DCAC_manual(Catch, depletion = 0.3, M = 0.2)\n\ncat(\"\\nРучной расчет DCAC:\\n\")\ncat(sprintf(\"  Средний улов: %.1f тыс. т\\n\", dcac_manual_result$avg_catch))\ncat(sprintf(\"  Истощение: %.0f%%\\n\", dcac_manual_result$depletion * 100))\ncat(sprintf(\"  Коэффициент коррекции: %.2f\\n\", dcac_manual_result$correction))\ncat(sprintf(\"  TAC = %.1f × %.2f = %.1f тыс. т\\n\", \n            dcac_manual_result$avg_catch, \n            dcac_manual_result$correction, \n            dcac_manual_result$tac))\n\n# ======================= МЕТОД 2: DB-SRA (Depletion-Based Stock Reduction Analysis) =======================\n\ncat(\"\\n========== МЕТОД DB-SRA ==========\\n\")\ncat(\"Стохастический анализ сокращения запаса\\n\\n\")\n\n# Функция для DB-SRA\nDBSRA &lt;- function(catch_data, depletion_prior = c(0.2, 0.5), \n                  r_prior = c(0.1, 0.6), nsim = 1000) {\n  \n  nyears &lt;- length(catch_data)\n  \n  # Массивы для хранения результатов\n  r_vals &lt;- numeric(nsim)\n  k_vals &lt;- numeric(nsim)\n  msy_vals &lt;- numeric(nsim)\n  b_final &lt;- numeric(nsim)\n  b_bmsy_final &lt;- numeric(nsim)\n  \n  # Счетчик успешных симуляций\n  success &lt;- 0\n  \n  cat(\"Запуск DB-SRA симуляций...\\n\")\n  pb &lt;- txtProgressBar(min = 0, max = nsim, style = 3)\n  \n  for (sim in 1:nsim) {\n    \n    # Генерация случайных параметров из приоров\n    r &lt;- runif(1, r_prior[1], r_prior[2])\n    init_depl &lt;- runif(1, depletion_prior[1], depletion_prior[2])\n    \n    # Начальная биомасса как доля от K\n    # K оценивается из максимального улова\n    k_guess &lt;- max(catch_data) * runif(1, 4, 12)\n    \n    # Инициализация биомассы\n    B &lt;- numeric(nyears + 1)\n    B[1] &lt;- k_guess * init_depl\n    \n    # Проекция популяции\n    for (t in 1:nyears) {\n      # Продукционная модель Шефера\n      surplus &lt;- r * B[t] * (1 - B[t]/k_guess)\n      \n      # Проверка, что улов не превышает доступную биомассу\n      if (catch_data[t] &gt; (B[t] + surplus) * 0.95) {\n        # Неудачная симуляция\n        break\n      }\n      \n      # Обновление биомассы\n      B[t+1] &lt;- B[t] + surplus - catch_data[t]\n      \n      # Проверка на отрицательную биомассу\n      if (B[t+1] &lt;= 0) {\n        break\n      }\n    }\n    \n    # Если симуляция успешна\n    if (t == nyears && B[nyears+1] &gt; 0) {\n      success &lt;- success + 1\n      \n      # Сохранение результатов\n      r_vals[success] &lt;- r\n      k_vals[success] &lt;- k_guess\n      msy_vals[success] &lt;- r * k_guess / 4  # MSY для модели Шефера\n      b_final[success] &lt;- B[nyears+1]\n      b_bmsy_final[success] &lt;- B[nyears+1] / (k_guess/2)\n    }\n    \n    setTxtProgressBar(pb, sim)\n  }\n  close(pb)\n  \n  # Обрезаем массивы до количества успешных симуляций\n  r_vals &lt;- r_vals[1:success]\n  k_vals &lt;- k_vals[1:success]\n  msy_vals &lt;- msy_vals[1:success]\n  b_final &lt;- b_final[1:success]\n  b_bmsy_final &lt;- b_bmsy_final[1:success]\n  \n  cat(sprintf(\"\\n✓ Успешных симуляций: %d из %d (%.1f%%)\\n\", \n              success, nsim, success/nsim*100))\n  \n  return(list(\n    r = r_vals,\n    k = k_vals,\n    msy = msy_vals,\n    b_final = b_final,\n    b_bmsy = b_bmsy_final,\n    n_success = success\n  ))\n}\n\n# Запуск DB-SRA\ndbsra_results &lt;- DBSRA(\n  catch_data = Catch,\n  depletion_prior = c(0.2, 0.5),\n  r_prior = c(0.1, 0.6),\n  nsim = 2000\n)\n\n# Вывод результатов DB-SRA\ncat(\"\\n--- Результаты DB-SRA ---\\n\")\ncat(sprintf(\"r (медиана): %.3f [%.3f - %.3f]\\n\", \n            median(dbsra_results$r),\n            quantile(dbsra_results$r, 0.25),\n            quantile(dbsra_results$r, 0.75)))\ncat(sprintf(\"K (медиана): %.1f [%.1f - %.1f] тыс. т\\n\",\n            median(dbsra_results$k),\n            quantile(dbsra_results$k, 0.25),\n            quantile(dbsra_results$k, 0.75)))\ncat(sprintf(\"MSY (медиана): %.1f [%.1f - %.1f] тыс. т\\n\",\n            median(dbsra_results$msy),\n            quantile(dbsra_results$msy, 0.25),\n            quantile(dbsra_results$msy, 0.75)))\ncat(sprintf(\"B/Bmsy текущее (медиана): %.2f [%.2f - %.2f]\\n\",\n            median(dbsra_results$b_bmsy),\n            quantile(dbsra_results$b_bmsy, 0.25),\n            quantile(dbsra_results$b_bmsy, 0.75)))\n\n# ======================= МЕТОД 3: CMSY (Catch-MSY) =======================\n\ncat(\"\\n========== МЕТОД CMSY ==========\\n\")\ncat(\"Catch-MSY метод (Froese et al. 2017)\\n\")\ncat(\"Байесовская оценка MSY из временного ряда уловов\\n\\n\")\n\n# Упрощенная реализация CMSY\nCMSY_simple &lt;- function(catch_data, resilience = \"Medium\", nsim = 10000) {\n  \n  nyears &lt;- length(catch_data)\n  \n  # Приоры для r на основе устойчивости (resilience)\n  r_priors &lt;- list(\n    \"Very low\" = c(0.015, 0.1),\n    \"Low\" = c(0.05, 0.5),\n    \"Medium\" = c(0.2, 1.0),\n    \"High\" = c(0.6, 1.5)\n  )\n  \n  r_range &lt;- r_priors[[resilience]]\n  \n  # Приоры для K (2-25 раз больше максимального улова)\n  k_range &lt;- c(max(catch_data) * 2, max(catch_data) * 25)\n  \n  # Приоры для начального и конечного истощения\n  # Основаны на трендах в уловах\n  catch_trend &lt;- mean(tail(catch_data, 3)) / mean(head(catch_data, 3))\n  \n  if (catch_trend &gt; 1.5) {\n    # Растущий тренд - запас был слабо эксплуатируемым\n    start_depl &lt;- c(0.5, 0.9)\n    end_depl &lt;- c(0.3, 0.7)\n  } else if (catch_trend &lt; 0.5) {\n    # Снижающийся тренд - запас истощается\n    start_depl &lt;- c(0.3, 0.7)\n    end_depl &lt;- c(0.01, 0.4)\n  } else {\n    # Стабильный тренд\n    start_depl &lt;- c(0.3, 0.7)\n    end_depl &lt;- c(0.2, 0.6)\n  }\n  \n  # Массивы для результатов\n  viable_r &lt;- numeric()\n  viable_k &lt;- numeric()\n  viable_msy &lt;- numeric()\n  viable_b &lt;- matrix(nrow = 0, ncol = nyears + 1)\n  \n  cat(\"Запуск CMSY с\", nsim, \"итерациями...\\n\")\n  pb &lt;- txtProgressBar(min = 0, max = nsim, style = 3)\n  \n  for (sim in 1:nsim) {\n    \n    # Случайные параметры\n    r &lt;- runif(1, r_range[1], r_range[2])\n    k &lt;- runif(1, k_range[1], k_range[2])\n    start_b &lt;- runif(1, start_depl[1], start_depl[2])\n    \n    # Траектория биомассы\n    B &lt;- numeric(nyears + 1)\n    B[1] &lt;- k * start_b\n    \n    viable &lt;- TRUE\n    \n    for (t in 1:nyears) {\n      # Продукция\n      surplus &lt;- r * B[t] * (1 - B[t]/k)\n      \n      # Проверка реалистичности\n      if (catch_data[t] &gt; B[t] + surplus) {\n        viable &lt;- FALSE\n        break\n      }\n      \n      # Обновление\n      B[t+1] &lt;- B[t] + surplus - catch_data[t]\n      \n      if (B[t+1] &lt;= 0 || B[t+1] &gt; k * 1.1) {\n        viable &lt;- FALSE\n        break\n      }\n    }\n    \n    # Проверка конечного истощения\n    final_depl &lt;- B[nyears+1] / k\n    if (viable && final_depl &gt;= end_depl[1] && final_depl &lt;= end_depl[2]) {\n      viable_r &lt;- c(viable_r, r)\n      viable_k &lt;- c(viable_k, k)\n      viable_msy &lt;- c(viable_msy, r * k / 4)\n      viable_b &lt;- rbind(viable_b, B)\n    }\n    \n    setTxtProgressBar(pb, sim)\n  }\n  close(pb)\n  \n  n_viable &lt;- length(viable_r)\n  cat(sprintf(\"\\n✓ Жизнеспособных комбинаций: %d из %d (%.1f%%)\\n\", \n              n_viable, nsim, n_viable/nsim*100))\n  \n  if (n_viable &lt; 10) {\n    cat(\"⚠ Слишком мало жизнеспособных результатов! Попробуйте другие настройки.\\n\")\n    return(NULL)\n  }\n  \n  # Расчет траекторий B/Bmsy и F/Fmsy\n  bmsy_mat &lt;- viable_k / 2  # Bmsy = K/2 для модели Шефера\n  bbmsy_trajectories &lt;- viable_b / bmsy_mat\n  \n  # F/Fmsy\n  ffmsy_trajectories &lt;- matrix(nrow = n_viable, ncol = nyears)\n  for (i in 1:n_viable) {\n    for (t in 1:nyears) {\n      f_t &lt;- catch_data[t] / viable_b[i, t]\n      fmsy &lt;- viable_r[i] / 2\n      ffmsy_trajectories[i, t] &lt;- f_t / fmsy\n    }\n  }\n  \n  return(list(\n    r = viable_r,\n    k = viable_k,\n    msy = viable_msy,\n    biomass = viable_b,\n    bbmsy = bbmsy_trajectories,\n    ffmsy = ffmsy_trajectories,\n    n_viable = n_viable\n  ))\n}\n\n# Запуск CMSY\ncmsy_results &lt;- CMSY_simple(\n  catch_data = Catch,\n  resilience = \"Medium\",\n  nsim = 10000\n)\n\nif (!is.null(cmsy_results)) {\n  # Вывод результатов CMSY\n  cat(\"\\n--- Результаты CMSY ---\\n\")\n  cat(sprintf(\"r: %.3f [%.3f - %.3f]\\n\",\n              median(cmsy_results$r),\n              quantile(cmsy_results$r, 0.025),\n              quantile(cmsy_results$r, 0.975)))\n  cat(sprintf(\"K: %.1f [%.1f - %.1f] тыс. т\\n\",\n              median(cmsy_results$k),\n              quantile(cmsy_results$k, 0.025),\n              quantile(cmsy_results$k, 0.975)))\n  cat(sprintf(\"MSY: %.1f [%.1f - %.1f] тыс. т\\n\",\n              median(cmsy_results$msy),\n              quantile(cmsy_results$msy, 0.025),\n              quantile(cmsy_results$msy, 0.975)))\n  \n  # Текущее состояние\n  current_bbmsy &lt;- cmsy_results$bbmsy[, nyears]\n  cat(sprintf(\"B/Bmsy (2024): %.2f [%.2f - %.2f]\\n\",\n              median(current_bbmsy),\n              quantile(current_bbmsy, 0.025),\n              quantile(current_bbmsy, 0.975)))\n  \n  current_ffmsy &lt;- cmsy_results$ffmsy[, nyears]\n  cat(sprintf(\"F/Fmsy (2024): %.2f [%.2f - %.2f]\\n\",\n              median(current_ffmsy),\n              quantile(current_ffmsy, 0.025),\n              quantile(current_ffmsy, 0.975)))\n}\n\n\n# ======================= МЕТОД 4: CC (Constant Catch) =======================\n\ncat(\"\\n========== МЕТОД CC (Constant Catch) ==========\\n\")\ncat(\"Простейший метод - постоянный улов на уровне исторического среднего\\n\\n\")\n\n# CC метод из DLMtool\nCC_results &lt;- CC1(\n  x = 1,\n  Data = CatchOnly_Data,\n  reps = 1\n)\n\n# Извлекаем результат из объекта Rec\nif(class(CC_results)[1] == \"Rec\") {\n  cc_tac &lt;- CC_results@TAC\n  \n  cat(\"--- Результаты CC ---\\n\")\n  cat(sprintf(\"Рекомендуемый TAC: %.1f тыс. т\\n\", cc_tac))\n  cat(\"(Средний исторический улов за последние 5 лет)\\n\")\n  cat(sprintf(\"Это составляет %.0f%% от текущего улова\\n\", \n              cc_tac/tail(Catch, 1) * 100))\n} else {\n  cc_tac &lt;- NA\n  cat(\"Ошибка: Неожиданный тип результата CC\\n\")\n}\n\n# ======================= ВИЗУАЛИЗАЦИЯ РЕЗУЛЬТАТОВ =======================\n\ncat(\"\\n========== СОЗДАНИЕ ГРАФИКОВ ==========\\n\")\n\n# 1. Сравнение оценок MSY\nif (!is.null(cmsy_results)) {\n  msy_comparison &lt;- data.frame(\n    Method = c(rep(\"DB-SRA\", length(dbsra_results$msy)),\n               rep(\"CMSY\", length(cmsy_results$msy))),\n    MSY = c(dbsra_results$msy, cmsy_results$msy)\n  )\n  \n  p2 &lt;- ggplot(msy_comparison, aes(x = Method, y = MSY, fill = Method)) +\n    geom_violin(alpha = 0.7, draw_quantiles = c(0.25, 0.5, 0.75)) +\n    geom_boxplot(width = 0.2, alpha = 0.9, outlier.shape = NA) +\n    scale_fill_viridis_d() +\n    labs(title = \"Сравнение оценок MSY\",\n         subtitle = \"Распределения из байесовских методов\",\n         x = \"\", y = \"MSY (тыс. т)\") +\n    theme_minimal() +\n    theme(legend.position = \"none\")\n  \n  print(p2)\n}\n# 2. Траектории B/Bmsy (для CMSY)\nif (!is.null(cmsy_results)) {\n  # Подготовка данных\n  bbmsy_median &lt;- apply(cmsy_results$bbmsy, 2, median)\n  bbmsy_q25 &lt;- apply(cmsy_results$bbmsy, 2, quantile, 0.25)\n  bbmsy_q75 &lt;- apply(cmsy_results$bbmsy, 2, quantile, 0.75)\n  bbmsy_q05 &lt;- apply(cmsy_results$bbmsy, 2, quantile, 0.05)\n  bbmsy_q95 &lt;- apply(cmsy_results$bbmsy, 2, quantile, 0.95)\n  \n  bbmsy_df &lt;- data.frame(\n    Year = c(Year, max(Year) + 1),\n    Median = bbmsy_median,\n    Q25 = bbmsy_q25,\n    Q75 = bbmsy_q75,\n    Q05 = bbmsy_q05,\n    Q95 = bbmsy_q95\n  )\n  \n  p3 &lt;- ggplot(bbmsy_df, aes(x = Year)) +\n    # 90% интервал\n    geom_ribbon(aes(ymin = Q05, ymax = Q95), alpha = 0.2, fill = \"blue\") +\n    # 50% интервал\n    geom_ribbon(aes(ymin = Q25, ymax = Q75), alpha = 0.4, fill = \"blue\") +\n    # Медиана\n    geom_line(aes(y = Median), size = 1.5, color = \"darkblue\") +\n    # Референсные линии\n    geom_hline(yintercept = 1, linetype = \"dashed\", color = \"black\") +\n    geom_hline(yintercept = 0.5, linetype = \"dotted\", color = \"red\") +\n    # Аннотации\n    annotate(\"text\", x = min(Year), y = 1.05, label = \"Bmsy\", hjust = 0) +\n    annotate(\"text\", x = min(Year), y = 0.55, label = \"0.5 Bmsy\", hjust = 0, color = \"red\") +\n    # Оформление\n    labs(title = \"Траектория B/Bmsy (CMSY)\",\n         subtitle = \"Медиана с 50% и 90% доверительными интервалами\",\n         x = \"Год\", y = \"B/Bmsy\") +\n    theme_minimal() +\n    coord_cartesian(ylim = c(0, 2))\n  \n  print(p3)\n}\n# 3. Фазовая диаграмма Кобе\nif (!is.null(cmsy_results)) {\n  # Проверяем размерности\n  cat(\"Размерность bbmsy:\", dim(cmsy_results$bbmsy), \"\\n\")\n  cat(\"Размерность ffmsy:\", dim(cmsy_results$ffmsy), \"\\n\")\n}  \n  # Для фазовой диаграммы нам нужны только годы с данными по уловам (не включая начальный год биомассы)\n  # bbmsy имеет 21 столбец (годы 0-20), ffmsy имеет 20 столбцов (годы 1-20)\n  # Используем столбцы 2:21 из bbmsy, чтобы соответствовать ffmsy\n  \n  # Медианные траектории\n  kobe_median &lt;- data.frame(\n    Year = Year,\n    BBmsy = apply(cmsy_results$bbmsy[, 2:(nyears+1)], 2, median),  # Столбцы 2:21\n    FFmsy = apply(cmsy_results$ffmsy, 2, median)  # Все столбцы\n  )\n  \n  # Альтернативный вариант - использовать последние значения для точечной диаграммы\n  kobe_current &lt;- data.frame(\n    BBmsy = cmsy_results$bbmsy[, nyears+1],  # Последний столбец bbmsy\n    FFmsy = cmsy_results$ffmsy[, nyears]      # Последний столбец ffmsy\n  )\n  \n  # График 1: Траектория во времени\n  p4 &lt;- ggplot() +\n    # Зоны Кобе\n    annotate(\"rect\", xmin = 0, xmax = 1, ymin = 1, ymax = 4,\n             fill = \"red\", alpha = 0.2) +\n    annotate(\"rect\", xmin = 1, xmax = 4, ymin = 1, ymax = 4,\n             fill = \"#FFA500\", alpha = 0.2) +\n    annotate(\"rect\", xmin = 0, xmax = 1, ymin = 0, ymax = 1,\n             fill = \"#FFFF00\", alpha = 0.2) +\n    annotate(\"rect\", xmin = 1, xmax = 4, ymin = 0, ymax = 1,\n             fill = \"green\", alpha = 0.2) +\n    \n    # Медианная траектория\n    geom_path(data = kobe_median, \n              aes(x = BBmsy, y = FFmsy),\n              linewidth = 1.5, color = \"black\",\n              arrow = arrow(length = unit(0.3, \"cm\"))) +\n    \n    # Точки по годам\n    geom_point(data = kobe_median,\n               aes(x = BBmsy, y = FFmsy, color = Year),\n               size = 3) +\n    \n    # Начало и конец\n    geom_point(data = kobe_median[1, ],\n               aes(x = BBmsy, y = FFmsy),\n               size = 5, shape = 17, color = \"blue\") +\n    geom_point(data = kobe_median[nrow(kobe_median), ],\n               aes(x = BBmsy, y = FFmsy),\n               size = 5, shape = 15, color = \"red\") +\n    \n    # Референсные линии\n    geom_vline(xintercept = 1, linetype = \"solid\", linewidth = 0.8) +\n    geom_hline(yintercept = 1, linetype = \"solid\", linewidth = 0.8) +\n    \n    # Оформление\n    scale_color_viridis_c() +\n    labs(title = \"Фазовая диаграмма Кобе (CMSY)\",\n         subtitle = \"Медианная траектория состояния запаса\",\n         x = \"B/Bmsy\", y = \"F/Fmsy\",\n         color = \"Год\") +\n    theme_minimal() +\n    coord_cartesian(xlim = c(0, 2), ylim = c(0, 3)) +\n    \n    # Подписи зон\n    annotate(\"text\", x = 0.5, y = 2, label = \"Перелов +\\nИстощение\", \n             size = 3, fontface = \"bold\") +\n    annotate(\"text\", x = 1.5, y = 2, label = \"Перелов\", \n             size = 3, fontface = \"bold\") +\n    annotate(\"text\", x = 0.5, y = 0.5, label = \"Истощение\", \n             size = 3, fontface = \"bold\") +\n    annotate(\"text\", x = 1.5, y = 0.5, label = \"Устойчивое\\nсостояние\", \n             size = 3, fontface = \"bold\", color = \"darkgreen\")\n  \n  print(p4)\n# График 2: Распределение текущего состояния с неопределенностью\n  p5 &lt;- ggplot(kobe_current, aes(x = BBmsy, y = FFmsy)) +\n    # Зоны Кобе\n    annotate(\"rect\", xmin = 0, xmax = 1, ymin = 1, ymax = 4,\n             fill = \"red\", alpha = 0.2) +\n    annotate(\"rect\", xmin = 1, xmax = 4, ymin = 1, ymax = 4,\n             fill = \"#FFA500\", alpha = 0.2) +\n    annotate(\"rect\", xmin = 0, xmax = 1, ymin = 0, ymax = 1,\n             fill = \"#FFFF00\", alpha = 0.2) +\n    annotate(\"rect\", xmin = 1, xmax = 4, ymin = 0, ymax = 1,\n             fill = \"green\", alpha = 0.2) +\n    \n    # Точки всех симуляций\n    geom_point(alpha = 0.3, size = 2, color = \"darkblue\") +\n    \n    # Контуры плотности\n    stat_density_2d(color = \"darkblue\", alpha = 0.7) +\n    \n    # Медиана\n    geom_point(aes(x = median(BBmsy), y = median(FFmsy)),\n               size = 5, color = \"red\", shape = 17) +\n    \n    # Референсные линии\n    geom_vline(xintercept = 1, linetype = \"solid\", linewidth = 0.8) +\n    geom_hline(yintercept = 1, linetype = \"solid\", linewidth = 0.8) +\n    \n    # Оформление\n    labs(title = \"Текущее состояние запаса (2024)\",\n         subtitle = sprintf(\"CMSY оценка с неопределенностью (%d симуляций)\", cmsy_results$n_viable),\n         x = \"B/Bmsy\", y = \"F/Fmsy\") +\n    theme_minimal() +\n    coord_cartesian(xlim = c(0, 2.5), ylim = c(0, 3)) +\n    \n    # Подписи зон\n    annotate(\"text\", x = 0.5, y = 2.5, label = \"Критическое\", \n             size = 3, fontface = \"bold\", color = \"darkred\") +\n    annotate(\"text\", x = 1.75, y = 2.5, label = \"Переэксплуатация\", \n             size = 3, fontface = \"bold\", color = \"darkorange\") +\n    annotate(\"text\", x = 0.5, y = 0.2, label = \"Восстановление\", \n             size = 3, fontface = \"bold\", color = \"goldenrod\") +\n    annotate(\"text\", x = 1.75, y = 0.2, label = \"Устойчивое\", \n             size = 3, fontface = \"bold\", color = \"darkgreen\")\n  \n  print(p5)\n# ======================= СВОДНАЯ ТАБЛИЦА РЕЗУЛЬТАТОВ =======================\n# Создание сводной таблицы с надежной обработкой NA\n# Сначала обрабатываем DCAC результат\ndcac_tac_value &lt;- 6.0  # Используем значение из ручного расчета как основу\nif (exists(\"DCAC_results\") && inherits(DCAC_results, \"Rec\") && !is.null(DCAC_results@TAC)) {\n  valid_tac &lt;- DCAC_results@TAC[!is.na(DCAC_results@TAC)]\n  if (length(valid_tac) &gt; 0) {\n    dcac_tac_value &lt;- median(valid_tac)\n  }\n}\n\n# Для DB-SRA и CMSY добавляем проверку на NA\ndbsra_msy &lt;- if (exists(\"dbsra_results\") && !is.null(dbsra_results$msy)) median(dbsra_results$msy, na.rm = TRUE) else NA\ncmsy_msy &lt;- if (!is.null(cmsy_results) && !is.null(cmsy_results$msy)) median(cmsy_results$msy, na.rm = TRUE) else NA\n\nsummary_table &lt;- data.frame(\n  Метод = c(\"DCAC\", \"DB-SRA\", \"CMSY\", \"CC\"),\n  \n  MSY = c(\n    NA,\n    if (!is.na(dbsra_msy)) sprintf(\"%.1f [%.1f-%.1f]\", \n                                 dbsra_msy,\n                                 quantile(dbsra_results$msy, 0.25, na.rm = TRUE),\n                                 quantile(dbsra_results$msy, 0.75, na.rm = TRUE))\n    else NA,\n    if (!is.null(cmsy_results) && !is.na(cmsy_msy)) sprintf(\"%.1f [%.1f-%.1f]\",\n                                                         cmsy_msy,\n                                                         quantile(cmsy_results$msy, 0.025, na.rm = TRUE),\n                                                         quantile(cmsy_results$msy, 0.975, na.rm = TRUE))\n    else NA,\n    NA\n  ),\n  \n  `B/Bmsy` = c(\n    NA,\n    if (exists(\"dbsra_results\") && !is.null(dbsra_results$b_bmsy)) sprintf(\"%.2f [%.2f-%.2f]\",\n                                                                       median(dbsra_results$b_bmsy, na.rm = TRUE),\n                                                                       quantile(dbsra_results$b_bmsy, 0.25, na.rm = TRUE),\n                                                                       quantile(dbsra_results$b_bmsy, 0.75, na.rm = TRUE))\n    else NA,\n    if (!is.null(cmsy_results)) sprintf(\"%.2f [%.2f-%.2f]\",\n                                      median(cmsy_results$bbmsy[, nyears], na.rm = TRUE),\n                                      quantile(cmsy_results$bbmsy[, nyears], 0.025, na.rm = TRUE),\n                                      quantile(cmsy_results$bbmsy[, nyears], 0.975, na.rm = TRUE))\n    else NA,\n    NA\n  ),\n  \n  `TAC рекомендация` = c(\n    sprintf(\"%.1f\", dcac_tac_value),  # Теперь точно будет 6.0\n    if (!is.na(dbsra_msy)) sprintf(\"%.1f\", dbsra_msy * 0.8) else NA,\n    if (!is.null(cmsy_results) && !is.na(cmsy_msy)) sprintf(\"%.1f\", cmsy_msy * 0.8) else NA,\n    sprintf(\"%.1f\", cc_tac)\n  ),\n  \n  Примечание = c(\n    \"Простая коррекция среднего улова\",\n    \"80% от MSY (предосторожность)\",\n    \"80% от MSY (предосторожность)\",\n    \"Средний исторический улов за последние 5 лет\"\n  ),\n  \n  stringsAsFactors = FALSE\n)\n\nprint(summary_table, row.names = FALSE)\n\n\n# ======================= РЕКОМЕНДАЦИИ =======================\ncat(\"\\n========== ИТОГОВЫЕ РЕКОМЕНДАЦИИ ==========\\n\\n\")\n\n# Анализ консенсуса методов\nall_tacs &lt;- c(\n  median(DCAC_results@TAC, na.rm = TRUE),  # Правильное извлечение TAC из S4 объекта\n  median(dbsra_results$msy, na.rm = TRUE) * 0.8,\n  ifelse(!is.null(cmsy_results), median(cmsy_results$msy, na.rm = TRUE) * 0.8, NA)\n)\n\n# Удаляем NA значения\nall_tacs &lt;- na.omit(all_tacs)\n\nconsensus_tac &lt;- median(all_tacs)\ntac_range &lt;- range(all_tacs)\n\ncat(\"АНАЛИЗ РЕЗУЛЬТАТОВ:\\n\")\ncat(strrep(\"-\", 50), \"\\n\")\ncat(sprintf(\"Консенсус TAC (медиана): %.1f тыс. т\\n\", consensus_tac))\ncat(sprintf(\"Диапазон рекомендаций: %.1f - %.1f тыс. т\\n\", tac_range[1], tac_range[2]))\ncat(sprintf(\"Текущий улов (2024): %.1f тыс. т\\n\", tail(Catch, 1)))\n\nif (consensus_tac &lt; tail(Catch, 1) * 0.8) {\n  cat(\"\\n⚠️ РЕКОМЕНДАЦИЯ: Существенно СНИЗИТЬ промысловое усилие\\n\")\n} else if (consensus_tac &lt; tail(Catch, 1)) {\n  cat(\"\\n⚠️ РЕКОМЕНДАЦИЯ: Умеренно СНИЗИТЬ промысловое усилие\\n\")\n} else {\n  cat(\"\\n✓ РЕКОМЕНДАЦИЯ: Текущий уровень промысла приемлем\\n\")\n}\n\n# Оценка состояния запаса\nif (!is.null(cmsy_results)) {\n  bbmsy_current &lt;- median(cmsy_results$bbmsy[, nyears])\n  if (bbmsy_current &lt; 0.5) {\n    cat(\"\\n🔴 СОСТОЯНИЕ ЗАПАСА: Критическое (B/Bmsy &lt; 0.5)\\n\")\n    cat(\"   Необходимы срочные меры по восстановлению\\n\")\n  } else if (bbmsy_current &lt; 1) {\n    cat(\"\\n🟡 СОСТОЯНИЕ ЗАПАСА: Ниже оптимального (0.5 &lt; B/Bmsy &lt; 1)\\n\")\n    cat(\"   Рекомендуется осторожный подход\\n\")\n  } else {\n    cat(\"\\n🟢 СОСТОЯНИЕ ЗАПАСА: Хорошее (B/Bmsy &gt; 1)\\n\")\n    cat(\"   Возможен устойчивый промысел\\n\")\n  }\n}\n\ncat(\"\\nПРЕДОСТОРОЖНЫЙ ПОДХОД:\\n\")\ncat(strrep(\"-\", 50), \"\\n\")\nprecautionary_tac &lt;- consensus_tac * 0.9\ncat(sprintf(\"Рекомендуемый TAC с учетом неопределенности: %.1f тыс. т\\n\", \n            precautionary_tac))\ncat(\"(90% от консенсусной оценки)\\n\")\n\n# ======================= СОХРАНЕНИЕ РЕЗУЛЬТАТОВ =======================\n\ncat(\"\\n========== СОХРАНЕНИЕ РЕЗУЛЬТАТОВ ==========\\n\")\n\n# Сохранение всех результатов\ncatch_only_results &lt;- list(\n  data = catch_df,\n  dcac = DCAC_results,\n  dbsra = dbsra_results,\n  cmsy = cmsy_results,\n  cc = CC_variants,\n  summary_table = summary_table,\n  recommendations = list(\n    consensus_tac = consensus_tac,\n    precautionary_tac = precautionary_tac,\n    current_catch = tail(Catch, 1)\n  )\n)\n\nsaveRDS(catch_only_results, \"catch_only_analysis.rds\")\ncat(\"✓ Результаты сохранены в 'catch_only_analysis.rds'\\n\")\n\n# Сохранение графиков\npdf(\"catch_only_plots.pdf\", width = 12, height = 10)\nprint(p1)  # Временной ряд уловов\nif (exists(\"p2\")) print(p2)  # Сравнение MSY\nif (exists(\"p3\")) print(p3)  # Траектории B/Bmsy\nif (exists(\"p4\")) print(p4)  # Диаграмма Кобе\nprint(p5)  # Сравнение TAC\ndev.off()\ncat(\"✓ Графики сохранены в 'catch_only_plots.pdf'\\n\")\n\n# Экспорт таблицы\nwrite.csv(summary_table, \"catch_only_summary.csv\", row.names = FALSE)\ncat(\"✓ Таблица сохранена в 'catch_only_summary.csv'\\n\")\n\ncat(\"\\n=============== АНАЛИЗ ЗАВЕРШЕН ===============\\n\")\n&gt; print(summary_table, row.names = FALSE)",
    "crumbs": [
      "<span class='chapter-number'>20</span>  <span class='chapter-title'>II. DLM: CATCH-ONLY METHODS (COM)</span>"
    ]
  },
  {
    "objectID": "chapter19.html#введение",
    "href": "chapter19.html#введение",
    "title": "20  II. DLM: CATCH-ONLY METHODS (COM)",
    "section": "",
    "text": "«В условиях неопределенности лучше быть приблизительно правым, чем точно ошибаться» — Джон Мейнард Кейнс\n\n\n\n\n\n\nподготовить данные уловов для DLM-анализа;\nзадать априорные параметры на основе биологических характеристик вида;\nзапустить и интерпретировать результаты методов CMSY, DB-SRA, DCAC;\nвизуализировать траектории B/Bmsy и F/Fmsy в фазовой плоскости Кобе;\nсравнить рекомендации по OДУ от разных методов и выработать консенсусную оценку.\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\nМетод\nMSY\nB.Bmsy\nTAC\nПримечание\n\n\n\n\nDCAC\n\n\n6.0\nПростая коррекция среднего улова\n\n\nDB-SRA\n29.4 [23.0-38.1]\n1.73 [1.48-1.82]\n23.58% от MSY\nПредосторожность\n\n\nCMSY\n17.7 [14.1-20.8]\n1.11 [0.62-1.35]\n14.28% от MSY\nПредосторожность\n\n\nCC\n\n\n11.6\nСредний исторический улов за последние 5 лет",
    "crumbs": [
      "<span class='chapter-number'>20</span>  <span class='chapter-title'>II. DLM: CATCH-ONLY METHODS (COM)</span>"
    ]
  },
  {
    "objectID": "chapter19.html#результаты-применения-моделей",
    "href": "chapter19.html#результаты-применения-моделей",
    "title": "20  II. DLM: CATCH-ONLY METHODS (COM)",
    "section": "20.2 Результаты применения моделей",
    "text": "20.2 Результаты применения моделей\nНа основе данных временного ряда уловов (2005-2024 гг.) с пиком в 35 тыс. т и текущим уровнем 12 тыс. т были получены следующие результаты:\n1. DCAC (Depletion-Corrected Average Catch)\n\nРезультат: Рекомендуемый TAC = 6.0 тыс. т\nСуть метода: Самый простой и консервативный метод. Берет средний исторический улов (16.6 тыс. т) и применяет к нему поправочный коэффициент, основанный на предполагаемом уровне истощения запаса (был задан на уровне 30%) и естественной смертности (M=0.2). Формула: TAC = Avg_Catch * Depletion * (1 + M).\nПлюсы:\n\nЧрезвычайно прост для понимания и расчета.\nКрайне предосторожен. В ситуации высокой неопределенности предотвращает дальнейшее истощение.\n\nМинусы:\n\nСильно зависит от априорного предположения о depletion (B/B₀). Если оценка истощения неточна, результат будет сильно смещен.\nНе дает оценок ключевых параметров популяции (r, K, MSY).\nИгнорирует динамику уловов (тренды), учитывая лишь среднее значение.\n\n\n2. DB-SRA (Depletion-Based Stock Reduction Analysis)\n\nРезультаты:\n\nMSY= 29.4 [23.0 - 38.1] тыс. т\nB/Bmsy (2024) = 1.73 (запас выше целевого уровня)\nTAC (80% от MSY) = 23.5 тыс. т\n\nСуть метода: Стохастический метод, который итеративно подбирает параметры r (темп роста) и K (емкость среды), чтобы смоделировать траекторию популяции под воздействием известных уловов. Исходит из того, что запас не мог быть полностью истощен за период промысла.\nПлюсы:\n\nУчитывает весь временной ряд уловов, а не только среднее значение.\nПрямо моделирует траекторию биомассы.\nДает полное распределение вероятностей для параметров (r, K, MSY) и текущего состояния запаса (B/Bmsy).\n\nМинусы:\n\nДает самые оптимистичные оценки среди всех методов. Это часто происходит из-за широких априорных допущений на r и K.\nМожет быть вычислительно затратным.\nСильно зависит от корректности априорных диапазонов для r и начального истощения.\n\n\n3. CMSY (Catch-MSY)\n\nРезультаты:\n\nMSY = 17.7 [14.1 - 20.8] тыс. т\nB/Bmsy (2024) = 1.11 (запас близок к целевому уровню)\nF/Fmsy (2024) = 0.61 (промысловое усилие ниже переловного)\nTAC (80% от MSY) = 14.2 тыс. т\n\nСуть метода: Байесовский метод, который перебирает тысячи пар r-K и отсеивает те, которые биологически невозможны (например, когда улов превышает возможную продуктивность). Оставшиеся “жизнеспособные” пары образуют распределение вероятностей для MSY и текущего состояния запаса.\nПлюсы:\n\nНадежный и популярный метод с хорошей теоретической базой.\nУчитывает тренды в уловах для определения правдоподобных диапазонов начального и конечного истощения.\nДает оценки как состояния запаса (B/Bmsy), так и промысла (F/Fmsy), что позволяет построить диаграмму Кобе.\nМенее чувствителен к точному значению depletion, чем DCAC, но более чувствителен, чем DB-SRA.\n\nМинусы:\n\nМожет иметь низкую “проходимость” (в данном случае лишь 2.1% симуляций были признаны жизнеспособными), что требует большого числа итераций.\nРезультаты могут быть чувствительны к выбору априорных диапазонов для r (на основе resilience).\n\n\n4. CC (Constant Catch)\n\nРезультат: Рекомендуемый TAC = 11.6 тыс. т\nСуть метода: Рекомендует постоянный улов на уровне среднего улова за последние 5 лет.\nПлюсы: Простота.\nМинусы: Слепое использование недавней истории может привести к рекомендациям, не связанным с реальным состоянием запаса (например, если последние 5 лет были периодом перелова).\n\n\n20.2.1 Сравнительная таблица результатов\n\n\n\n\n\n\n\n\n\n\n\nМетод\nРекомендуемый TAC (тыс. т)\nОценка MSY (тыс. т)\nОценка B/Bmsy\nПреимущества\nНедостатки\n\n\n\n\nDCAC\n6.0\n-\n-\nКрайняя предосторожность, простота\nСильная зависимость от априорного depletion, не дает MSY\n\n\nDB-SRA\n23.5\n29.4\n1.73\nУчет динамики уловов, моделирование биомассы\nЧасто излишне оптимистичный, широкие априоры\n\n\nCMSY\n14.2\n17.7\n1.11\nБаланс предосторожности и оптимизма, оценка B/Bmsy и F/Fmsy\nНизкая “проходимость”, чувствительность к априорам на r\n\n\nCC\n11.6\n-\n-\nПростота\nСлепое использование данных, не отражает состояние запаса\n\n\n\n\n\n20.2.2 Причина различий в оценках\nРазброс в оценках TAC от 6.0 до 23.5 тыс. т является прямым следствием различных математических допущений и априорной информации, заложенной в каждый метод.\n\nРазные фундаментальные подходы:\n\nDCAC исходит из текущего состояния истощения.\nDB-SRA и CMSY исходят из продуктивности популяции (параметры r и K), чтобы найти MSY, а затем определяют состояние запаса.\n\nЧувствительность к разным априорным предположениям:\n\nDCAC чувствителен к depletion.\nCMSY чувствителен к resilience (что задает широкий априорный диапазон для r).\nDB-SRA чувствителен к априорным диапазонам как для r, так и для depletion.\n\nИнтерпретация истории уловов:\nРезкий рост уловов с последующим спадом может интерпретироваться по-разному:\n\nCMSY видит в этом признаки перелова и оценивает запас как близкий к Bmsy.\nDB-SRA, с его более широкими априорами, может счесть этот спад не столь критичным и оценить запас как значительно превышающий Bmsy.\n\nУровень предосторожности:\nDCAC по дизайну самый предосторожный. DB-SRA часто оказывается самым оптимистичным. CMSY занимает промежуточное положение.\n\n\n\n20.2.3 Шаги по последующему улучшению оценок\nЧтобы уменьшить неопределенность и выбрать наиболее обоснованное управленческое решение, необходимо:\n\nРешить вопрос с априорными допущениями (ключевой шаг!):\n\nПровести анализ чувствительности. Запустить все модели, систематически меняя ключевые априорные распределения (например, depletion для DCAC, диапазоны r для CMSY и DB-SRA).\nОбосновать априорные распределения параметров на основе биологии вида. Использовать данные по близким видам-аналогам (например, из базы данных FishBase) для задания более реалистичных и узких диапазонов для r, M, Linf и т.д. Это самое слабое место DLM-анализа.\n\nИнтегрировать дополнительные данные (переход на Tier 2-3):\n\nДанные CPUE: Даже единственная точка данных об относительной численности (например, от индекса стандартизированного CPUE) может быть использована для калибровки моделей (например, в методе BSM или SPiCT) и резкого сужения неопределенности.\nДанные о размере/возрасте: Если есть выборочные данные о длине или возрасте, можно применить методы LBB (Length-Based Bayesian) или LBSPR для независимой оценки B/Bmsy, F/Fmsy и M. Эти оценки затем можно использовать для калибровки catch-only методов.\n\nПровести взвешивание моделей (Model Averaging):\n\nПосле анализа чувствительности и, если возможно, калибровки, не обязательно выбирать одну модель. Можно использовать средневзвешенное значение рекомендаций TAC, где вес модели определяется ее правдоподобием (например, на основе AIC) или соответствием независимым данным.\n\nПринять предосторожный подход:\n\nВ условиях сохраняющейся неопределенности разумно принять консенсусную, но предосторожную оценку. В данном случае консенсус медианных оценок моделей (DCAC, DB-SRA, CMSY) составляет ~18.8 тыс. т. Однако, учитывая, что две модели (DCAC и CMSY) указывают на необходимость более осторожного подхода, а текущий улов составляет 12 тыс. т, рекомендация TAC на уровне 12-14 тыс. т (с последующим мониторингом) выглядит наиболее обоснованной и соответствующей принципу предосторожности.\n\n\nВывод: Разброс в оценках — это не ошибка, а отражение неопределенности. Задача аналитика — не просто запустить скрипт, а сузить эту неопределенность за счет обоснования априорных распределений параметров и интеграции всех доступных данных, а затем сформулировать управленческую рекомендацию, явно учитывающую оставшуюся неопределенность.",
    "crumbs": [
      "<span class='chapter-number'>20</span>  <span class='chapter-title'>II. DLM: CATCH-ONLY METHODS (COM)</span>"
    ]
  },
  {
    "objectID": "chapter17.html",
    "href": "chapter17.html",
    "title": "18  GMM кластеризация: Определение широкопалости самцов краба-стригуна",
    "section": "",
    "text": "18.1 Введение\nОпределение функциональной зрелости у самцов крабов-стригунов — одна из тех задач, где биология встречается с статистикой лицом к лицу, и где простое наблюдение часто уступает место изощренному анализу. У самцов краба-стригуна переход к половозрелости маркируется драматическим изменением морфометрии: узкие, почти изящные клешни неполовозрелого «ювениала» (фенотип “узкопалый”) сменяются массивным, брутальным инструментом половозрелого самца (фенотип “широкопалый”). Этот аллометрический скачок — не просто украшение, а ключевой адаптивный признак, определяющий успех в боях за территорию и самок, а значит, и репродуктивный вклад особи. Проблема в том, что в природе редко встречаются учебные примеры; вместо этого она подсовывает нам сплошной континуум, где самый тощий жених запросто может оказаться рядом с самым упитанным холостяком, а шум измерений и индивидуальная изменчивость довершают картину хаоса. Задача исследователя — найти объективную границу в этом континууме, разделив популяцию на две функциональные группы, даже если сами крабы об этой границе не подозревают.\nМетод «классификация без учителя» — это по сути попытка найти скрытую структуру в данных, когда у нас есть измерения, но нет заранее известных меток. Мы как бы спрашиваем данные: “На какие осмысленные группы вы сами хотите распасться?”. Базовые методы вроде k-means пытаются сделать это жестко, проставляя границы по принципу ближайшего центра, что часто приводит к ошибкам на перекрывающихся хвостах распределений. Иерархическая кластеризация видит структуру вложенно, но чувствительна к шуму и опять-таки требует субъективного выбора уровня отсечения. Модели гауссовских смесей (Gaussian mixture models; GMM) подходят к задаче иначе — они не просто группируют точки, а предполагают, что каждая точка порождена одной из нескольких вероятностных моделей (компонент смеси), каждая из которых является многомерным нормальным распределением со своими параметрами — вектором средних и ковариационной матрицей. Это мощное допущение: оно позволяет каждой группе иметь свою собственную форму, размер и ориентацию в пространстве признаков, что биологически осмысленно — ведь мы и ожидаем, что “широкопалые” особи будут не только в среднем крупнее, но и иметь иную форму соотношения ширины карапакса и клешни по сравнению с “узкопалыми”. Преимущество GMM в том, что это мягкая, вероятностная кластеризация; вместо того чтобы насильно приписывать наблюдение к кластеру, модель оценивает вероятность принадлежности, что особенно ценно для пограничных случаев, которые в биологии встречаются сплошь и рядом. Однако и у классического GMM есть ахиллесова пята — он, как и большинство методов, основанных на нормальном распределении, чувствителен к выбросам. Стоит появиться нескольким аномально крупным или, наоборот, мелким особям, и оценки параметров могут сместиться, а границы кластеров — исказиться. Именно здесь на сцену выходит робастная (robust) GMM, основанная на t-распределении Стьюдента. t-распределение имеет более тяжелые хвосты, чем гауссово, что позволяет модели терпимее относиться к выбросам — они перестают быть “проблемными точками, которые нужно во что бы то ни стало объяснить”, а становятся просто маловероятными, но допустимыми событиями. Робастная GMM не пытается подогнать компоненты смеси под все точки сразу, а более устойчиво оценивает параметры основных, центральных групп, игнорируя экстремальные отклонения. Т.е. подобен человеку, который на шумной вечеринке слушает не всех сразу, а только тех, кто говорит внятно и по делу, мудро игнорируя пьяные дискуссии о работе. В контексте нашей задачи это важно: полевые данные по крабам почти всегда зашумлены — возможны ошибки промеров, наличие больных или травмированных особей, наконец, просто природные аномалии, которые не отменяют общего правила. Использование робастной GMM позволяет нам сосредоточиться на основной биологической сигнатуре — различии между двумя фенотипами, — не позволяя шуму заглушить этот сигнал. Таким образом, применение такой разновидности GMM это не просто технический выбор, а методологическая необходимость, позволяющая извлечь из данных истинную биологическую структуру, скрытую за завесой естественной изменчивости и погрешности измерения.",
    "crumbs": [
      "<span class='chapter-number'>18</span>  <span class='chapter-title'>GMM кластеризация: Определение широкопалости самцов краба-стригуна</span>"
    ]
  },
  {
    "objectID": "chapter17.html#введение",
    "href": "chapter17.html#введение",
    "title": "18  GMM кластеризация: Определение широкопалости самцов краба-стригуна",
    "section": "",
    "text": "Рис. 1.: Краб-стригун опилио узкопалый (вверху) и широкопалый (внизу)",
    "crumbs": [
      "<span class='chapter-number'>18</span>  <span class='chapter-title'>GMM кластеризация: Определение широкопалости самцов краба-стригуна</span>"
    ]
  },
  {
    "objectID": "chapter17.html#данные-и-скрипты",
    "href": "chapter17.html#данные-и-скрипты",
    "title": "18  GMM кластеризация: Определение широкопалости самцов краба-стригуна",
    "section": "18.2 Данные и скрипты",
    "text": "18.2 Данные и скрипты\nИсходные данные по ширине карапакса и высоте клешни находятся здесь. Скрипты можно скачать целиком: Первый - три разновидности метода классификации, включая обычную GMM. Второй – робастная GMM. Третий – прогноз с использованием робастной GMM.\n\n\n\nРис. 2.: Визуализация кластерного анализа половозрелости краба-стригуна опилио тремя методами классификации без учителя\n\n\n\n\n\nРис. 3.: Результаты использования робастной модели гауссовских смесей (GMM)",
    "crumbs": [
      "<span class='chapter-number'>18</span>  <span class='chapter-title'>GMM кластеризация: Определение широкопалости самцов краба-стригуна</span>"
    ]
  }
]
{"title":"Анализ и визуализация данных улова","markdown":{"yaml":{"title":"Анализ и визуализация данных улова","format":"html"},"headingText":"Введение","containsRefs":false,"markdown":"\n\n\nЭто занятие — про первый шаг в анализе уловов: аккуратно загрузить данные, посмотреть на них без иллюзий и задать простые, проверяемые вопросы. Мы будем работать в R, потому что он честно показывает структуру данных и не скрывает неудобные детали. Наша цель сейчас не «сделать красиво», а убедиться, что мы видим именно то, что реально записано в файле: сколько строк, какие переменные, каких они типов и не прячутся ли среди них ошибки, способные испортить весь последующий анализ.\n\nНачинаем с того, чтобы R «видел» правильную папку. Рабочая директория должна указывать туда, где лежит файл shrimp_catch.csv. Простая установка пути — это не бюрократия, а воспроизводимость: на другом компьютере тот же код должен читать те же данные, а не «что‑то похожее». После этого подключаем tidyverse: это набор инструментов, который унифицирует чтение, преобразование и визуализацию. read_csv считывает таблицу и сразу создаёт tibble — «вежливую» версию data.frame с чётким хранением типов. Уже на этом шаге стоит помнить о банальных, но частых ловушках: десятичный разделитель должен совпадать с вашими региональными настройками, пустые строки и «NA» в файле должны превращаться в пропуски, а не в нули или текст.\n\nПервичный осмотр — это короткий разговор с данными без интерпретации. Команда glimpse выдаёт компактный снимок: сколько строк, каковы названия столбцов и их классы, примеры значений. В нашем наборе ожидаем пять столбцов: id как целое число, age как целое число 1–4, length как числовая величина длины, weight как числовая величина массы и sex как текстовый признак пола. Если вы видите, что length внезапно «chr» или sex закодирован числами — это сигнал остановиться и привести типы в порядок сейчас, а не объяснять странные результаты потом. Аналогичная команда str показывает внутреннюю структуру и подтверждает, что R понимает объект так же, как и вы. Эти две команды — «микроскоп 4×»: быстро и без украшательств.\n\nДальше имеет смысл задать несколько контрольных вопросов, которые одновременно проверяют здравый смысл и раскрывают базовую статистику. summary покажет минимумы, медианы и квартильные точки для количественных переменных и распределение для категориальных. Если где‑то возникает отрицательный вес, нулевая длина или возраст за пределами 1–4 — это не «особенности популяции», это данные, требующие чистки. table и prop.table дадут частоты по полу; если соотношение полов выглядит нереалистично для вашей промысловой выборки — проверьте этап предобработки. Наконец, простой cor.test между длиной и весом покажет, есть ли ожидаемая сильная положительная связь; но здесь важно помнить о дисциплине: корреляция — это не причинность, и даже высокая r требует подтверждения графиком рассеяния и проверкой на аутлаеры.\n\nЗачем столько внимания «мелочам» до любых моделей? Потому что в прикладной биостатистике именно этот участок пути отделяет полезные выводы от красивых, но пустых графиков. Проверка типов и диапазонов, явное обращение с пропусками, подтверждение структурой — это те скромные процедуры, которые экономят часы на поздних этапах. И если позволить себе лёгкую ремарку, то лучший способ повысить интеллектуальную честность анализа — не верить по умолчанию ни себе, ни данным, пока вы не посмотрели на них под простейшим светом glimpse и str.\n\nКогда эти шаги пройдены, можно переходить к описательной статистике и первичной визуализации. Гистограмма длины даст быстрый набросок формы распределения, а простые группировки по возрасту покажут, как меняются средние и разброс. Но это уже следующий раздел. Сейчас важнее, чтобы R и вы одинаково понимали, что такое «наши данные», и чтобы каждый последующий результат опирался на корректно загруженную и проверенную таблицу [shrimp_catch.csv](https://mombus.github.io/cRab/data/shrimp_catch.csv).\n\n## Загрузка данных и первичный осмотр\n\nссылка на файл: [shrimp_catch.csv](https://mombus.github.io/cRab/data/shrimp_catch.csv)\n\n```{r}\n#| output: false\n#| eval: false\n# Установка рабочей директории\nsetwd(\"C:/TEXTBOOK/\")\n# Загрузка библиотек\nlibrary(tidyverse)\n# Загрузка данных\ndata <- read_csv(\"shrimp_catch.csv\")\n\n```\n\nКоманда `glimpse` знакомит со структурой данных:\n\n```{r}\n#| output: false\n#| eval: false\n# Просмотр структуры и первых строк загруженных данных\nglimpse(data)\n```\n\n```{r}\n#| output: false\n#| eval: false\nRows: 230\nColumns: 5\n$ id     <int> 1, 2, 3, 4, 5, 6, 7, 8, 9, 10, 11, 12, 13, 14, 15, 16, 17, 18, ~\n$ age    <int> 2, 4, 4, 4, 1, 4, 2, 2, 4, 3, 4, 3, 2, 1, 2, 1, 2, 2, 2, 2, 3, ~\n$ length <dbl> 20.45450, 25.88928, 29.42257, 30.68292, 12.46059, 28.52152, 17.~\n$ weight <dbl> 1.28221748, 1.97476899, 2.65412595, 3.44746476, 0.13404801, 2.3~\n$ sex    <chr> \"M\", \"F\", \"F\", \"F\", \"M\", \"F\", \"M\", \"M\", \"F\", \"F\", \"F\", \"F\", \"M\"~\n> \n```\n\nМожно использовать команду `str` — показывает внутреннюю **структуру** объекта , включая количество строк, столбцов, названия переменных, их типы (`chr`, `num`, `int` и др.), а также несколько первых значений.\n\n```{r}\n#| output: false\n#| eval: false\nstr(data)\n```\n\n```{r}\n#| output: false\n#| eval: false\n'data.frame':   230 obs. of  5 variables:\n $ id    : int  1 2 3 4 5 6 7 8 9 10 ...\n $ age   : int  2 4 4 4 1 4 2 2 4 3 ...\n $ length: num  20.5 25.9 29.4 30.7 12.5 ...\n $ weight: num  1.282 1.975 2.654 3.447 0.134 ...\n $ sex   : chr  \"M\" \"F\" \"F\" \"F\" ...\n>\n```\n\n## Описательная статистика и визуализация\n\nКоманда `summary` выводит **описательную статистику** для каждой числовой переменной: минимум, 1-й квартиль, медиана, среднее, 3-й квартиль, максимум; для категориальных переменных — частоты.\n\n```{r}\n#| output: false\n#| eval: false\n# Общая статистика\nsummary(data)\n```\n\n```{r}\n#| output: false\n#| eval: false\n       id              age            length          weight       \n Min.   :  1.00   Min.   :1.000   Min.   : 7.65   Min.   :-0.3334  \n 1st Qu.: 58.25   1st Qu.:2.000   1st Qu.:17.62   1st Qu.: 0.6320  \n Median :115.50   Median :3.000   Median :22.49   Median : 1.3660  \n Mean   :115.50   Mean   :2.509   Mean   :21.68   Mean   : 1.4933  \n 3rd Qu.:172.75   3rd Qu.:3.000   3rd Qu.:26.03   3rd Qu.: 2.1148  \n Max.   :230.00   Max.   :4.000   Max.   :36.02   Max.   : 5.1316  \n     sex           \n Length:230        \n Class :character  \n Mode  :character  \n```\n\nПростейшими командами можно вычислить, например, соотоношение полов или корреляцию длина-вес.\n\n```{r}\n#| output: false\n#| eval: false\n# Соотношение полов\nprop.table(table(data$sex)) %>% round(2)\n```\n\n```{r}\n#| output: false\n#| eval: false\n   F    M \n0.35 0.65 \n```\n\n```{r}\n#| output: false\n#| eval: false\n# Корреляция длина-вес с p-value\ncor_test <- cor.test(data$length, data$weight, \n                     method = \"pearson\", \n                     exact = FALSE,\n                     na.action = na.omit)\n \ncor_coef <- round(cor_test$estimate, 2)\np_value <- scales::pvalue(cor_test$p.value, accuracy = .001)\n \ncat(\"Корреляция Пирсона: r =\", cor_coef, \", p =\", p_value, \"\\n\")\n```\n\n```{r}\n#| output: false\n#| eval: false\nКорреляция Пирсона: r = 0.95 , p = <0.001 \n```\n\n```{r}\n#| output: false\n#| eval: false\n# Распределение возраста\ntable(data$age)\n```\n\n```{r}\n#| output: false\n#| eval: false\n1  2  3  4 \n43 68 77 40 \n```\n\n```{r}\n#| output: false\n#| eval: false\n# Средние значения длины и веса по группам\ndata %>%\n   group_by(age) %>%\n   summarise(\n     mean_length = mean(length),\n     sd_length = sd(length),\n     mean_weight = mean(weight),\n     sd_weight = sd(weight))\n```\n\n```{r}\n#| output: false\n#| eval: false\n# A tibble: 4 x 5\n    age mean_length sd_length mean_weight sd_weight\n  <dbl>       <dbl>     <dbl>       <dbl>     <dbl>\n1     1        12.7      1.37       0.249     0.234\n2     2        19.2      1.88       0.919     0.341\n3     3        24.8      1.72       1.88      0.424\n4     4        29.1      2.28       2.96      0.804\n> \n\n```\n\n### Построение гистограммы для переменной 'length' (длина креветок)\n\nДля первого визуального знакомства команда `hist` строит гистограмму — простой график, который показывает, как распределены значения числовой переменной. В данном случае отображается распределение длин креветок из набора данных.\n\n```{r}\n#| output: false\n#| eval: false\nhist(data$length, \n     main = \"Гистограмма длины креветок\",          # Заголовок графика\n     xlab = \"Длина (см)\",                          # Подпись оси X\n     ylab = \"Частота\",                             # Подпись оси Y\n     col = \"lightblue\",                            # Цвет столбцов\n     border = \"black\",                             # Цвет границ столбцов\n     breaks = 15)                                   # Количество интервалов\n```\n\n![Рис. 1.1: Гистограмма длины креветок](images/hist_shrimp.PNG){fig-align=\"center\" width=\"60%\"}\n\n### Визуализация в `ggridges`\n\nДля элегантных и компактных графиков подходит библиотека `ggridges`. Построим распределение длины креветки в зависимости от пола и возраста.\n\n```{r}\n#| output: false\n#| eval: false\nlibrary(ggplot2)\nlibrary(ggridges)\n\nggplot(data, aes(x = length, \n                 y = sex, \n                 group = sex, \n                 fill = sex)) +\n  geom_density_ridges(scale = 2, alpha = 0.7) +\n  scale_y_discrete(expand = c(0, 0)) +\n  scale_x_continuous(expand = c(0, 0)) +\n  labs(\n    title = \"Распределение длины карапакса по полу\",\n    x = \"Длина карапакса (мм)\",\n    y = \"Пол\"\n  ) +\n  theme(\n    panel.border = element_blank(),  # Убирает рамку вокруг графика\n    axis.line = element_line(color = \"black\")  # Сохраняет осевые линии (опционально)\n  )\n\n```\n\n![Рис. 1.2: Пол-длина креветок с использованием `ggridges`](images/ggridges_shrimp.PNG){fig-align=\"center\" width=\"60%\"}\n\n## Выявление аутлайеров (выбросов)\n\nАутлаеры (выбросы) — наблюдения, значительно отклоняющиеся от общего распределения данных. Их идентификация критически важна, так как они могут искажать результаты анализа. Один из надёжных методов обнаружения выбросов — **метод межквартильного размаха (IQR)**.\n\n### **Теория метода**\n\n1.  **Расчёт квартилей**:\n\n    -   **Q1** (25-й перцентиль): значение, ниже которого находится 25% данных.\n\n    -   **Q3** (75-й перцентиль): значение, ниже которого находится 75% данных.\n\n    -   **IQR = Q3 - Q1**: мера разброса средней половины данных.\n\n2.  **Границы аутлаеров**:\n\n    -   **Нижняя граница**: Q1−1.5×IQRQ1−1.5×IQR\n\n    -   **Верхняя граница**: Q3+1.5×IQRQ3+1.5×IQR\\\n        Наблюдения за этими пределами считаются выбросами.\n\n### **Преимущества метода**\n\n-   Устойчивость к асимметрии распределения.\n\n-   Не требует предположения о нормальности данных.\n\n```{r}\n#| output: false\n#| eval: false\n\n# Метод межквартильного размаха\noutliers <- data %>%\n  mutate(\n    length_z = scale(length),\n    weight_z = scale(weight)\n  ) %>% \n  filter(abs(length_z) > 3 | abs(weight_z) > 3)\n\n# Визуализация\nggplot(data, aes(x = length, y = weight)) +\n  geom_point(aes(color = \"Обычные\"), alpha = 0.5) +\n  geom_point(data = outliers, aes(color = \"Аутлаеры\"), size = 3) +\n  scale_color_manual(values = c(\"Обычные\" = \"grey50\", \"Аутлаеры\" = \"red\")) +\n  labs(title = \"Выявление аномальных наблюдений\", color = \"Тип\")\n```\n\n![Рис. 1.3: Распределение длины карапакса](images/outliers_shrimp.PNG){fig-align=\"center\" width=\"60%\"}\n\n## Определение возрастной структуры: статистические методы анализа размерных данных\n\n**Лирическое отступление**\n\nОпределять возрастную структуру по размерным данным — это не попытка «угадать» возраст, а дисциплинированный способ выделить в общей смеси несколько закономерных мод, за которыми почти всегда стоят биологические процессы: вариации в пополнении, различия в темпах роста, селективность промысла. Мы не видим возраст напрямую, зато видим след его накопления в длине, и задача статистики здесь — разложить смешанное распределение на осмысленные компоненты, не выдавая желаемое за действительное. Начинать разумно с простого: гистограмма и сглаженная плотность дают первичную картину, где «пики» — это кандидаты на возрастные группы. Выбор ширины бинов (диапазонов) — не косметика: слишком широкие бины сливают моды, слишком узкие создают шумовые «зубцы». Ядерная плотность полезна как независимая проверка: если пик виден и на гистограмме, и на сглаженной плотности, это хороший знак. Уже на этом шаге важно исключить явные аутлаеры и убедиться, что анализируется однородная по сезону и району выборка: смешение сезонов способно превратить один чёткий пик в два слабых и наоборот.\n\nK‑means привлекателен скоростью и простотой, но его допущения жестковаты для биологии: он делит по ближайшему центру и фактически предполагает равные дисперсии у групп. Для черновой разметки это приемлемо: задали *K*, получили кластеры, посмотрели, не распилили ли явный пик пополам и не смешали ли крайние хвосты. Но трактовать эти кластеры как «возрастные классы» без дополнительных проверок нельзя. Минимальный набор проверок — «локальный смысл»: центры кластеров должны быть упорядочены по длине, доли групп не должны выглядеть абсурдно для вашей системы, а границы между кластерами — приходиться на спады между модами гистограммы. Полезно пробежать несколько значений *K*, посмотреть «локоть» по внутрикластерной дисперсии или силуэт; если модель жадно «доедает» шум, она не помогает задаче.\n\nДекомпозиция смесью нормалей с EM‑алгоритмом ближе к тому, что нам нужно: каждая компонента имеет свой средний размер, свою дисперсию и свою долю, а принадлежность особи — вероятностная, а не «жёсткая». Это лучше отражает реальность: возрастные группы перекрываются, и жёсткое отнесение на границе избыточно уверенно. Здесь ключевая инженерная мысль — инициализация и выбор числа компонент. Стартовать можно от пиковой структуры гистограммы или от грубых центров k‑means; число компонент выбирать по BIC/AIC и здравому смыслу, помня, что каждая лишняя компонента почти всегда «объясняет» шум. Параметры смеси имеют прозрачную интерпретацию: *μ* — модальный размер группы, *σ* — разброс (ростовая гетерогенность плюс измерительная ошибка), *λ* — доля группы в выборке. Для отчётности полезно ранжировать компоненты по μ, чтобы избежать «перескока меток» между запусками, и дать доверительные интервалы (обычный приём — бутстрэп).\n\nМетод Бхаттачарии, классика промысловой статистики, по сути делает то же в терминах гистограммы: линейнизует лог‑разности соседних бинов и позволяет визуально «вынуть» наклон, соответствующий компоненте нормального распределения. Он чувствителен к выбору ширины бина и к ровности хвостов, зато нагляден и хорошо работает там, где пики действительно нормальны и отделены. В паре с EM это сильная связка: Бхаттачария помогает выбрать разумное *K* и старт, EM — уточняет параметры и даёт вероятностные принадлежности. Сопоставление результатов этих двух подходов повышает доверие: если оба «видят» четыре группы с близкими μ, это гораздо лучше, чем красивый рисунок одного метода.\n\nНа практике полезно придерживаться алгоритма «снизу вверх». Сначала — чистая визуализация: гистограмма, ядерная плотность, по возможности разрезы по полу и возрасту полевой маркировки; это помогает понять, не смешиваем ли мы биологически разные контексты. Затем — черновая кластеризация k‑means для ориентировочных центров и грубого *K*. Далее — смеси нормалей с EM, выбор *K* по BIC и проверка стабильности решения от разных стартов. После подгонки — диагностика: наложить компоненты и суммарную смесь на гистограмму, проверить, не «улетели» ли *σ*, нет ли «дублирующих» компонент с почти одинаковыми *μ*, сопоставить *λ* с ожидаемыми долями когорт. И главное — помнить, что «модальные группы по длине» и «возрастные классы» совпадают не автоматом: для перевода мод в возраст нужен ростовой ключ (например, параметры Берталанфи) или независимая информация о когортности. Без этого честнее говорить «модальные размерные группы».\n\nНаконец, стоит держать в голове пару дисциплинарных напоминаний. Любая смесь будет пытаться объяснить артефакты данных, поэтому контроль качества измерений и фильтрация аутлаеров — не опция, а необходимость. Сезонная выборка и выборочная выловленность сдвигают доли и средние: если орудия ловят неравномерно, *λ* смеси — это не «структура популяции», а «структура улова». И, как бы прозаично это ни звучало, фиксируйте зерно генератора случайных чисел и документируйте выбор *K* и стартовые значения: это делает ваш результат воспроизводимым, а спор — предметным. Такой дисциплинированный ход — от картинки к модели, от модели к диагностике, от диагностики к осторожной интерпретации — позволяет извлечь из длины то, что она действительно хранит про возраст, и не больше.\n\nИ так, возрастная структура популяции — часто важна для расчёта промысловой смертности, оценки репродуктивного потенциала и прогнозирования динамики запасов. Поскольку прямое измерение возраста часто невозможно (например, у беспозвоночных или рыб без четких возрастных меток), используются статистические методы, выделяющие группы в смешанных распределениях размеров.\n\n**Основные подходы:**\n\n1.  **Метод k-средних (k-means)** — алгоритм кластеризации, группирующий особи в заданное число кластеров (возрастных групп) на основе их размеров.\n\n2.  **Метод Бхаттачарии** — статистический подход для разделения смешанных нормальных распределений, часто применяемый для идентификации мод в гистограммах.\n\n3.  **EM-алгоритм** — оценка параметров смеси распределений, подходящая для данных с перекрывающимися возрастными группами.\n\n4.  **Гауссовы смеси (GMM)** — расширение метода Бхаттачарии для многомерного анализа.\n\n5.  **Ядерное сглаживание** — непараметрический метод визуализации плотности, помогающий выявить скрытые моды.\n\nРассмотрим метод k-средних (k-means) и метод Бхаттачарии, предварительно построив гистограмму.\n\n```{r}\n#| output: false\n#| eval: false\n\n# Загрузка библиотек\nlibrary(tidyverse)\nlibrary(mixtools)\n# Гистограмма длины с наложением плотности\nggplot(data, aes(x = length)) +\n  geom_histogram(aes(y = after_stat(density)), fill = \"steelblue\", bins = 20, alpha = 0.7) +\n  geom_density(color = \"#FC4E07\", linewidth = 1) +\n  labs(title = \"Распределение длины карапакса\", \n       subtitle = \"Пики могут соответствовать возрастным группам\",\n       x = \"Длина (мм)\")\n```\n\n![Рис. 1.3: Распределение длины карапакса](images/hist_dens_shrimp.PNG){fig-align=\"center\" width=\"60%\"}\n\n```{r}\n#| output: false\n#| eval: false\n# Кластеризация по длине (K-means как пример)\nset.seed(123)\nclusters <- kmeans(data$length, centers = 4)  # Предполагаем 4 возрастные группы\ndata$cluster <- factor(clusters$cluster)\n\n# Визуализация кластеров\nggplot(data, aes(x = length, fill = cluster)) +\n  geom_histogram(bins = 25, alpha = 0.7) +\n  labs(title = \"Кластеризация по длине)\", \n       x = \"Длина (мм)\")\n```\n\n![Рис. 1.4: Кластеризация по длине](images/cluster_shrimp.PNG){fig-align=\"center\" width=\"60%\"}\n\n```{r}\n#| output: false\n#| eval: false\n# Установка рабочей директории\nsetwd(\"C:/TEXTBOOK/\")\n\n# Загрузка библиотек\nlibrary(tidyverse)\nlibrary(mixtools)\n\n# Загрузка данных\ndata <- read.csv(\"shrimp_catch.csv\")\n\n# 1. Построение и отображение гистограммы\nhist(data$length, breaks = 20, main = \"Гистограмма распределения длин карапаксов\",\n     xlab = \"Длина карапакса (мм)\", ylab = \"Частота\")\n\n# 2. Инициализация параметров (предположим 4 возрастные группы)\ninit_params <- list(\n  lambda = rep(1/4, 4),\n  mu = c(13, 19, 25, 32),\n  sigma = c(1.5, 1.75, 1.75, 2.5)\n)\n\n# 3. Разделение смеси распределений методом EM\nfit <- normalmixEM(data$length, k = 4, maxit = 1000, epsilon = 1e-3,\n                   lambda = init_params$lambda,\n                   mu = init_params$mu,\n                   sigma = init_params$sigma)\n\n# 4. Визуализация результатов с ggplot2\n# Генерация сетки для построения кривых\nx_grid <- seq(min(data$length), max(data$length), length.out = 500)\n\n# Функция смеси\nmixture_density <- function(x) {\n  fit$lambda[1] * dnorm(x, fit$mu[1], fit$sigma[1]) +\n  fit$lambda[2] * dnorm(x, fit$mu[2], fit$sigma[2]) +\n  fit$lambda[3] * dnorm(x, fit$mu[3], fit$sigma[3]) +\n  fit$lambda[4] * dnorm(x, fit$mu[4], fit$sigma[4])\n}\n\n# График\nggplot(data, aes(x = length)) +\n  # Гистограмма\n  geom_histogram(aes(y = after_stat(density)), bins = 20, fill = \"white\", color = \"black\", alpha = 0.7) +\n  # Исходное распределение (гладкая линия)\n  geom_density(color = \"red\", lwd = 1.2) +\n  # Смесь распределений\n  stat_function(fun = mixture_density, color = \"black\", lwd = 1.5) +\n  # Компоненты смеси\n  stat_function(fun = function(x) fit$lambda[1] * dnorm(x, fit$mu[1], fit$sigma[1]), color = \"blue\", lwd = 1) +\n  stat_function(fun = function(x) fit$lambda[2] * dnorm(x, fit$mu[2], fit$sigma[2]), color = \"green\", lwd = 1) +\n  stat_function(fun = function(x) fit$lambda[3] * dnorm(x, fit$mu[3], fit$sigma[3]), color = \"orange\", lwd = 1) +\n  stat_function(fun = function(x) fit$lambda[4] * dnorm(x, fit$mu[4], fit$sigma[4]), color = \"purple\", lwd = 1) +\n  \n  # Настройка темы и легенды\n  theme_minimal() +\n  labs(\n    x = \"Длина карапакса (мм)\",\n    y = \"Плотность\",\n    title = \"Разделение возрастных групп методом EM\"\n  )\n```\n\n![Рис. 1.5: Метод Бхаттачарии](images/bhattacharya_shrimp.PNG){fig-align=\"center\" width=\"60%\"}\n\n## Уравнение Берталанфи\n\nУравнение Берталанфи — фундаментальная модель в рыбохозяйственной науке, описывающая асимптотический рост организмов. Оно имеет вид: $$\nL(t) = L_{\\infty} \\cdot \\left(1 - e^{-k \\cdot (t - t_0)}\\right)\n$$ где *L~∞~*— теоретическая максимальная длина особи, *k*— коэффициент скорости роста, *t~0~*— гипотетический возраст при нулевой длине.\n\nВ приведённом коде модель применяется для анализа роста северной креветки :\n\n1.  **Подготовка данных**: Удаление аутлаеров (например, строк 10 и 50) повышает точность оценки параметров.\n\n2.  **Инициализация параметров**:\n\n    -   *L~∞~* задаётся как максимальная наблюдаемая длина в данных.\n\n    -   *k* и *t~0~* подбираются итеративно методом нелинейных наименьших квадратов (**`nls`**).\n\n3.  **Визуализация**: График сопоставляет эмпирические данные (точки) с предсказаниями модели (красная линия), демонстрируя, как рост замедляется с приближением к *L∞*.\n\n**Интерпретация параметров**:\n\n-   Высокое значение *k* (\\>0.3) указывает на быстрый рост молоди.\n\n-   *t~0~*\\<0 может отражать ранний метаморфоз личинок.\n\n```{r}\n#| output: false\n#| eval: false\n# Загрузка библиотек\nlibrary(ggplot2)\nlibrary(dplyr)\nlibrary(nlme)\n\n# Загрузка данных\ndata <- read.csv(\"shrimp_catch.csv\")\n\n# Преобразование возраста в числовой формат\ndata$age_num <- as.numeric(data$age)\n\n# Удаление аутлайеров (если необходимо)\ndata_clean <- data %>%\n  filter(!id %in% c(10, 50))  # Пример удаления строк с аномалиями\n\n# Начальные параметры на основе данных\nL_inf_start <- max(data_clean$length, na.rm = TRUE)  # Максимальная длина\nk_start <- 0.3                                        # Средняя скорость роста\nt0_start <- -0.5                                      # Гипотетический возраст\n\n# Подгонка модели с увеличенным числом итераций\nmodel <- nls(\n  length ~ L_inf * (1 - exp(-k * (age_num - t0))),\n  data = data_clean,\n  start = list(L_inf = L_inf_start, k = k_start, t0 = t0_start),\n  control = nls.control(maxiter = 200, warnOnly = TRUE)  # Увеличиваем лимит итераций\n)\n\n# Вывод результатов\nsummary(model)\n\n# Создание последовательности возрастов для предсказания\nage_seq <- seq(min(data_clean$age_num), max(data_clean$age_num), by = 0.1)\n\n# Предсказание значений длины\nlength_pred <- predict(model, newdata = data.frame(age_num = age_seq))\n\n# Построение графика\nggplot(data_clean, aes(x = age_num, y = length)) +\n  geom_point(aes(color = age), alpha = 0.7) +\n  geom_line(data = data.frame(age_num = age_seq, length = length_pred), \n            aes(x = age_num, y = length), color = \"red\", linewidth = 1.2) +\n  labs(\n    title = \"Рост креветок по уравнению Берталанфи\",\n    x = \"Возраст (годы)\",\n    y = \"Длина карапакса (мм)\",\n    color = \"Возрастная группа\"\n  ) +\n  theme_minimal()\n\n# Сохранение графика\nggsave(\"bertalanffy_model.png\", width = 8, height = 6)\n```\n\n![Рис. 1.6: Рост креветок по уравнению Берталанфи](images/bertalanffy_model.PNG){fig-align=\"center\" width=\"60%\"}\n\n## Огива, логистическая кривая и 50%-ное созревание\n\nЛогистическая регрессия удобна там, где исход — бинарный: созрел/не созрел, самка/самец. Для протоандрической креветки вероятность быть самкой естественно растёт с длиной, и логистическая кривая описывает это гладким переходом от 0 к 1; её центральная точка даёт L50 = −β0/β1 — длину, при которой половина особей уже самки. Огива — это та же история, но накопительно: как доля самок нарастает по мере увеличения длины; она наглядна для сравнения годов/районов и проверки сдвигов зрелости. Качество модели удобно проверять ROC/AUC: AUC ≈ 0.9+ означает, что длина хорошо ранжирует вероятность женского пола, но не отменяет проверки калибровки. Знак и величина β1 интерпретируются просто: положительный β1 — с каждым миллиметром шансы быть самкой растут, exp(β1) — во сколько раз растут эти шансы на единицу длины. Биологически L50 концентрирует ключевой сигнал: при стабильных условиях он держится в узком интервале (для *Pandalus borealis* около 25–28 мм), а его снижение обычно маркирует стресс среды или избирательный вылов, «подталкивающий» к более раннему созреванию. В прикладном учёте это даёт два практичных числа — L50 и AUC — и две опоры для интерпретации: насколько резко идёт переход (крутизна кривой) и насколько надёжен прогноз (дискриминация и калибровка).\n\nЛогистическая кривая — ключевой инструмент для моделирования бинарных процессов, таких как созревание или смена пола у организмов. В случае протоандрических креветок (*Pandalus borealis*), которые меняют пол с возрастом, зависимость вероятности быть самкой от длины карапакса можно описать логистической функцией:\n\n$$\nP(F) = \\frac{1}{1 + e^{-(\\beta_0 + \\beta_1 \\cdot длина)}}\n$$\n\nгде *P(F)* — вероятность принадлежности к женскому полу, *β~0~* — интерсепт, *β~1~* — коэффициент влияния длины.\n\nТочка перегиба логистической кривой соответствует длине, при которой вероятность быть самкой равна 50%: $$\nL_{50} = -\\frac{\\beta_0}{\\beta_1}\n$$\n\n![Рис. 1.7: Логистическая кривая](images/logistic_model_shrimp.PNG){fig-align=\"center\" width=\"60%\"}\n\nОгива (кумулятивная кривая) показывает накопление вероятности с увеличением длины. Для анализа созревания её можно построить через интеграл логистической функции. Визуально она демонстрирует, как доля самок возрастает с размером.\n\n![Рис. 1.8: Огива](images/ogive_shrimp.PNG){fig-align=\"center\" width=\"60%\"}\n\n### **Оценка модели**\n\n1.  **ROC-кривая и AUC**:\n\n    -   Площадь под ROC-кривой (AUC) \\>0.7 указывает на хорошую предсказательную способность модели.\n\n    -   Значение AUC = 0.94(пример из кода) подтверждает сильную связь длины и пола.\n\n![Рис. 1.9: ROC-кривая и AUC](images/ROC_shrimp.PNG){fig-align=\"center\" width=\"60%\"}\n\n2.  **Интерпретация коэффициентов**:\n\n    -   Положительный *β~1~* означает: с ростом длины вероятность быть самкой увеличивается.\n\n    -   Например, *β~1~*=0.25 → увеличение длины на 1 мм повышает шансы в e^0.25^≈1.28 раза.\n\n### **Биологический контекст**\n\n-   **Протоандрический гермафродитизм**: У креветок смена пола с самцов на самок происходит при достижении критического размера (\\~25-28 мм).\n\n-   **L50 как индикатор**: Снижение *L~50~* в популяции может сигнализировать о стрессовых условиях (перелов, изменение среды), ускоряющих созревание.\n\n```{r}\n#| output: false\n#| eval: false\n# Установка рабочей директории\nsetwd(\"C:/TEXTBOOK/\")\n\n# Загрузка библиотек\nlibrary(tidyverse)\nlibrary(pROC)\nlibrary(ggplot2)\n\n# Загрузка данных\ndata <- read_csv(\"shrimp_catch.csv\")\n\n# 1. Предобработка данных -----------------------------------------------------\n# Удаление аутлаеров методом IQR\nQ1 <- quantile(data$length, 0.25)\nQ3 <- quantile(data$length, 0.75)\nIQR <- Q3 - Q1\ndata_clean <- data %>%\n  filter(length >= Q1 - 1.5*IQR & length <= Q3 + 1.5*IQR)\n\n# 2. Логистическая регрессия --------------------------------------------------\n# Преобразование пола в бинарную переменную\ndata_clean$sex_binary <- ifelse(data_clean$sex == \"F\", 1, 0)\n\n# Подгонка модели\nmodel_logit <- glm(sex_binary ~ length, \n                   data = data_clean, \n                   family = binomial(link = \"logit\"))\n\n# Расчет коэффициентов\nbeta0 <- coef(model_logit)[1]\nbeta1 <- coef(model_logit)[2]\n\n# Вычисление L50 (длина 50% созревания)\nL50 <- round(-beta0/beta1, 1)\n\n# 3. Визуализация ------------------------------------------------------------\n# Логистическая кривая\nggplot(data_clean, aes(x = length, y = sex_binary)) +\n  geom_point(aes(color = sex), alpha = 0.6, size = 2) +\n  geom_line(aes(y = predict(model_logit, type = \"response\")), \n            color = \"#D81B60\", linewidth = 1.5) +\n  geom_vline(xintercept = L50, linetype = \"dashed\", color = \"#1E88E5\") +\n  annotate(\"text\", x = L50 + 2, y = 0.2, \n           label = paste(\"L50 =\", L50, \"мм\"), color = \"#1E88E5\") +\n  scale_color_manual(values = c(\"#FFC107\", \"#1976D2\")) +\n  labs(\n    title = \"Зависимость пола от длины карапакса\",\n    subtitle = \"Логистическая регрессия с 50%-ной точкой созревания\",\n    x = \"Длина карапакса (мм)\",\n    y = \"Вероятность быть самкой (P(F))\"\n  ) +\n  theme_minimal(base_size = 12)\n\n# Огива (кумулятивное распределение)\ndata_ogive <- data_clean %>%\n  arrange(length) %>%\n  mutate(\n    cum_females = cumsum(sex_binary),\n    cum_prob = cum_females / max(cum_females)\n  )\n\nggplot(data_ogive, aes(x = length, y = cum_prob)) +\n  geom_line(color = \"#4CAF50\", linewidth = 1.5) +\n  geom_vline(xintercept = L50, linetype = \"dashed\", color = \"#1E88E5\") +\n  geom_hline(yintercept = 0.5, linetype = \"dotted\", color = \"#757575\") +\n  annotate(\"text\", x = L50 + 2, y = 0.55, \n           label = paste(\"50% созревание при\", L50, \"мм\"), color = \"#1E88E5\") +\n  scale_y_continuous(labels = scales::percent) +\n  labs(\n    title = \"Огива: Кумулятивное распределение самок\",\n    x = \"Длина карапакса (мм)\",\n    y = \"Накопленная доля самок\"\n  ) +\n  theme_minimal(base_size = 12)\n\n# 4. Оценка модели -----------------------------------------------------------\n# ROC-анализ\nroc_obj <- roc(data_clean$sex_binary, predict(model_logit, type = \"response\"))\nauc_value <- round(auc(roc_obj), 2)\n\n# График ROC-кривой\nplot(roc_obj, col = \"#E53935\", main = paste(\"ROC-кривая (AUC =\", auc_value, \")\"))\n\n# 5. Сохранение результатов --------------------------------------------------\nggsave(\"logistic_curve.png\", width = 8, height = 6, dpi = 300)\nggsave(\"ogive_curve.png\", width = 8, height = 6, dpi = 300)\n\n# Вывод ключевых метрик\ncat(\"Результаты анализа:\\n\")\ncat(\"- Длина 50%-ного созревания (L50):\", L50, \"мм\\n\")\ncat(\"- AUC модели:\", auc_value, \"\\n\")\ncat(\"- Коэффициенты модели:\\n\")\ncat(\"  Intercept (β0):\", round(beta0, 2), \"\\n\")\ncat(\"  Slope (β1):\", round(beta1, 2), \"\\n\")\n```\n\n## Сравнение групп, параметров, моделей\n\nСравнивать группы — это не про охоту за маленькими p-value, а про проверяемые ответы на конкретные биологические вопросы. «Самки длиннее самцов?» — переводим в аккуратную статистическую формулировку, начинаем с гигиены данных и только потом подбираем тест. Предобработка банальна, но критична: убираем очевидные аутлаеры по понятному правилу (IQR или заранее согласованный протокол), не «чистим» хвосты до совершенства, сохраняем независимость наблюдений. Разбиваем выборку на подмножества по полу, проверяем типы переменных, смотрим на формы распределений и пропуски. И дальше — не прыжок к t‑тесту, а короткая остановка у предпосылок: нормальность и гомогенность дисперсий — это про остатки и разумность аппроксимации, а не про «магическое число 0.05». При несхожих дисперсиях уместнее Уэлч, при явной ненормальности и неробастности — Манн–Уитни, а при больших n классический t‑тест часто держится благодаря центральной предельной теореме. В любом случае голые p‑значения не заканчивают разговор: эффект размера (Cohen’s d) и доверительные интервалы говорят «на сколько», а не только «есть/нет».\n\nВизуализация в этом месте — не иллюстрация, а часть доказательства. Boxplot/violin помогают увидеть медианы, разброс и асимметрию; добавленная на график оценка p‑value дисциплинирует интерпретацию, но не подменяет её. Полезно в той же системе координат показать точки, чтобы помнить: каждая точка — отдельная особь, а не абстрактная «генеральная совокупность». И если позволить себе короткую «сапольскину» ремарку: мозг с удовольствием «видит» разницу там, где её нет, поэтому лучше сначала смотреть на график, потом на число, а не наоборот.\n\nКогда вопрос — уже не «кто крупнее», а «кто растёт быстрее», сравнение средних сменяется сравнением параметров модели. Самый прозрачный путь — объединённая линейная модель с взаимодействием: length \\~ age \\* sex. Значимый коэффициент при взаимодействии — это формализованная фраза «наклоны различаются». Диагностика здесь важнее, чем когда‑либо: линейность, разброс остатков, потенциальные leverage‑точки. Альтернатива — раздельные модели по полу и прямое сравнение наклонов через тест Вальда; он удобен как независимая проверка и часто даёт те же выводы, что и взаимодействие, если структура данных не экзотична. Интерпретация должна оставаться биологической: различающиеся наклоны — это не «магия пола», а потенциальная разница в темпе роста, доступе к корму или сезоне отбора проб.\n\nДальше мы неизбежно приходим к форме связи «вес–длина». Линейная модель соблазнительно проста, но биологически мир чаще степенной: масса масштабируется примерно как длина в степени 3, с поправками на форму и состояние. Полиномиальная регрессия третьего порядка часто выигрывает в AIC и R², потому что ловит сгибы и плечи; у неё есть и оборотная сторона — склонность к переобучению и слабая интерпретируемость коэффициентов. Степенная модель почти всегда немного проигрывает по «сухим метрикам», зато даёт ясный смысл: параметр b близок к 3 — всё ожидаемо; заметное отклонение — есть предмет для обсуждения физиологии, питания, сезонности. Какой из подходов «лучший»? Тот, у которого остатки ведут себя прилично, AIC не кричит о лишней сложности, а биолог рассказывает связную историю, не пряча глаза. Хорошая практика — сопоставить все три, показать таблицу R²/AIC, приложить графики остатков и проговорить компромисс между точностью и объяснимостью.\n\nИ в сравнении групп, и в сравнении параметров, и в выборе модели действуют три простых правила. Первое — формулируйте вопрос до теста: это экономит десятки необязательных проверок. Второе — показывайте эффект с интервалами: «на сколько» важнее «насколько значимо». Третье — проверяйте устойчивость: замены теста (t ↔ Уэлч ↔ Манн–Уитни), альтернативная спецификация модели, бутстрэп интервалов — всё это помогает отличить сигнал от удачного совпадения. И, наконец, не забывайте про контекст отбора проб: если улов по орудиям и глубинам неоднороден, то и выводы про «среднего самца» или «типичную самку» легко превращаются в выводы про «типичный улов». Статистическая аккуратность здесь — это не педантизм, а способ говорить о биологии без самообмана.\n\n### Сравнение групп (на примере самцов и самок)\n\nРассмотрим методы сравнения количественных характеристик (длина, вес) между самцами и самками северной креветки. Анализ включает проверку нормальности распределения, выбор подходящего статистического теста и визуализацию различий.\n\n#### Подготовка данных\n\nЗагрузим данные и выделим подвыборки для самцов и самок:\n\n```{r}\n#| output: false\n#| eval: false\n# Установка рабочей директории\nsetwd(\"C:/TEXTBOOK/\")\n\n# Загрузка библиотек  \nlibrary(tidyverse)  \nlibrary(ggplot2)  \nlibrary(rstatix)\nlibrary(ggpubr)\n\n# Загрузка данных  \ndata <- read_csv(\"shrimp_catch.csv\") %>%\n  filter(!id %in% c(10, 50))  # Удаление аномальных наблюдений \n\n# Фильтрация данных по полу  \nmales <- data %>% filter(sex == \"M\")  \nfemales <- data %>% filter(sex == \"F\") \n```\n\n#### Проверка нормальности распределения\n\nПеред сравнением групп проверим, соответствуют ли данные нормальному распределению (тест Шапиро-Уилка):\n\n```{r}\n#| output: false\n#| eval: false\n# Проверка нормальности для длины самцов  \nshapiro_test(males$length)  \n# Проверка нормальности для длины самок  \nshapiro_test(females$length) \n```\n\nЕсли p-value \\> 0.05, распределение считается нормальным. В противном случае используем непараметрические методы.\n\n#### Сравнение средних значений\n\nЕсли данные нормальны: t-тест\n\n```{r}\n#| output: false\n#| eval: false\n# T-тест для сравнения длин самцов и самок  \nt_test_result <- t_test(length ~ sex, data = data)  \nt_test_result \n```\n\nЕсли данные не нормальны: U-тест Манна-Уитни\n\n```{r}\n#| output: false\n#| eval: false\n# U-тест для сравнения длин самцов и самок  \nmannwhitney_result <- wilcox_test(length ~ sex, data = data)  \nmannwhitney_result \n```\n\n#### Эффект размера (коэффициент Коэна)\n\nДля оценки практической значимости различий рассчитаем коэффициент Коэна:\n\n```{r}\n#| output: false\n#| eval: false\n# Расчет коэффициента Коэна  \ncohens_d_result <- cohens_d(length ~ sex, data = data)  \ncohens_d_result  \n```\n\n-   **d \\< 0.2** : малый эффект,\n\n-   **d ≈ 0.5** : средний эффект,\n\n-   **d \\> 0.8** : большой эффект.\n\n#### **Визуализация различий**\n\nПостроим boxplot для визуального сравнения длин самцов и самок:\n\n```{r}\n#| output: false\n#| eval: false\nggplot(data, aes(x = sex, y = length, fill = sex)) +  \n  geom_boxplot(color = \"black\", alpha = 0.7) +  \n  stat_compare_means(method = \"t.test\") +  # Добавление p-value  \n  labs(title = \"Сравнение длин самцов и самок\",  \n       x = \"Пол\", y = \"Длина карапакса (мм)\") +  \n  theme_minimal() \n```\n\n![Рис. 1.10: Boxplot сравнения длин самцов и самок](images/ttest_shrimp.PNG){fig-align=\"center\" width=\"60%\"}\n\n#### **Интерпретация результатов**\n\n1.  Если p-value \\< 0.05, различия между группами статистически значимы.\n\n2.  Эффект размера помогает оценить биологическую важность различий. Например, если самки значительно крупнее самцов (d = 1.2), это может указывать на половой диморфизм, связанный с репродуктивной стратегией.\n\n    #### **Пример полного анализа для веса**\n\n```{r}\n#| output: false\n#| eval: false\n# Полный анализ для веса  \nweight_analysis <- data %>%  \n  group_by(sex) %>%  \n  summarise(  \n    mean_weight = mean(weight),  \n    sd_weight = sd(weight),  \n    n = n()  \n  ) %>%  \n  mutate(  \n    t_test = list(t_test(weight ~ sex, data = data)),  \n    cohens_d = list(cohens_d(weight ~ sex, data = data))  \n  )  \n\n# Вывод результатов  \nprint(weight_analysis) \n\n# Распределение веса по полу\nggplot(data, aes(x = factor(sex), y = weight, fill = factor(sex))) +\n  geom_violin(trim = FALSE, alpha = 0.7) +\n  geom_boxplot(width = 0.2, outlier.shape = NA, fill = \"white\") +\n  labs(title = \"Распределение веса по полу\", x = \"Пол\", y = \"Вес (г)\") +\n  theme_minimal()\n```\n\n![Рис. 1.12: Violin plot для визуализации распределения веса](images/violin_shrimp.PNG){fig-align=\"center\" width=\"60%\"}\n\n#### **Выводы**\n\n1.  Используйте t-тест для нормальных данных и U-тест для ненормальных.\n\n2.  Дополните анализ оценкой эффекта размера для биологической интерпретации.\n\n3.  Визуализируйте различия с помощью boxplot или violin plot.\n\n**Рекомендации** :\n\n-   Для многомерных данных (например, одновременное сравнение длины, веса и возраста) применяйте MANOVA.\n\n-   Если группы неоднородны (например, разный возрастной состав), используйте ковариационный анализ (ANCOVA).\n\n    ### **Что делать, если тест на нормальность не пройден для одной из групп?**\n\n    При сравнении количественных характеристик (например, длины карапакса у самцов и самок) важно учитывать, соответствуют ли данные нормальному распределению. Если тест на нормальность (например, Шапиро-Уилка) показывает значимое отклонение от нормальности для одной из групп, это влияет на выбор статистического теста и интерпретацию результатов.\n\n    #### **Пример из нашего анализа**\n\n    Мы провели сравнение длины карапакса между самцами и самками:\n\n    -   Для самцов: **`shapiro_test(males$length)`** → p-value = **0.000574** (нормальность отвергнута).\n\n    -   Для самок: **`shapiro_test(females$length)`** → p-value = **0.891** (нормальность подтверждена).\n\n    Несмотря на это, мы применили как **t-тест** , так и **U-тест Манна-Уитни** :\n\n    -   **t-тест** : p-value = 1.46e-40 (значимо).\n\n    -   **U-тест** : p-value = 1.97e-27 (значимо).\n\n    -   Коэффициент Коэна: d = 2.14 (большой эффект).\n\n    #### **Почему это работает?**\n\n    1.  **t-тест устойчив к умеренным отклонениям от нормальности** :\n\n        -   При больших выборках (n \\> 30) центральная предельная теорема позволяет использовать t-тест даже при слабо выраженной асимметрии.\n\n        -   В вашем случае выборка самцов (n = 149) достаточно велика, чтобы компенсировать отклонение от нормальности.\n\n    2.  **U-тест Манна-Уитни — непараметрическая альтернатива** :\n\n        -   Этот тест не требует нормальности и сравнивает ранги, а не средние значения.\n\n        -   Он подтверждает значимость различий, что усиливает доверие к выводу.\n\n    3.  **Эффект размера (коэффициент Кобена)** :\n\n        -   d = 2.14 указывает на **большой эффект** , что важно для биологической интерпретации, даже если p-values значимы.\n\n### Сравнение параметров (линейные модели для оценки межгрупповых различий)\n\nДля сравнения параметров двух линейных моделей (например, скорости роста самцов и самок) используем следующий подход.\n\n```{r}\n#| output: false\n#| eval: false\n# Установка рабочей директории\nsetwd(\"C:/TEXTBOOK/\")\n\n# Загрузка библиотек\nlibrary(tidyverse)\nlibrary(ggplot2)\nlibrary(broom)\nlibrary(knitr)\n\n# Загрузка данных\ndata <- read_csv(\"shrimp_catch.csv\") %>%\n  filter(!id %in% c(10, 50))  # Удаление аномальных наблюдений\n\n# Фильтрация данных по полу\ndata_male <- data %>% filter(sex == \"M\")\ndata_female <- data %>% filter(sex == \"F\")\n\n# Построение моделей\nmodel_male <- lm(length ~ age, data = data_male)\nmodel_female <- lm(length ~ age, data = data_female)\n\nggplot(data, aes(age, length, color = sex)) +\n  geom_point(alpha = 0.5) +\n  geom_smooth(method = \"lm\", formula = y ~ x) +\n  scale_color_manual(values = c(\"#E7B800\", \"#00AFBB\")) +\n  labs(x = \"Возраст\", y = \"Длина (мм)\") +\n  theme_minimal()\n```\n\n![Рис. 1.15: Визуализация моделей](images/comparison_shrimp.PNG){fig-align=\"center\" width=\"60%\"}\n\n**Метод 1: Объединенная модель с взаимодействиями**\n\n```{r}\n#| output: false\n#| eval: false\n# Установка рабочей директории\njoint_model <- lm(length ~ age * sex, data = data)\nsummary(joint_model) %>% \n  broom::tidy() %>% \n  filter(term == \"age:sexM\") %>% \n  kable(caption = \"Проверка различия наклонов\", digits = 3)\n\n```\n\n```{r}\n#| output: false\n#| eval: false\nTable: Проверка различия наклонов\n\n|term     | estimate| std.error| statistic| p.value|\n|:--------|--------:|---------:|---------:|-------:|\n|age:sexM |     1.86|     0.459|     4.053|       0|\n> \n\n```\n\n**Интерпретация:**\\\nЗначимый коэффициент взаимодействия **`age:sexM`** (p \\< 0.05) указывает на статистически значимые различия в скорости роста между полами.\n\n**Метод 2: Тест Вальда**\n\n```{r}\n#| output: false\n#| eval: false\nlibrary(car)\ndelta_beta <- coef(model_male)[\"age\"] - coef(model_female)[\"age\"]\nse_diff <- sqrt(vcov(model_male)[\"age\",\"age\"] + vcov(model_female)[\"age\",\"age\"])\nz_score <- delta_beta / se_diff\np_value <- 2 * pnorm(-abs(z_score))\n\ncat(\"Разница коэффициентов:\", round(delta_beta, 3), \n    \"\\nZ-статистика:\", round(z_score, 3),\n    \"\\np-value:\", format.pval(p_value, digits = 2))\n\n\ncomparison_table <- data.frame(\n  Параметр = c(\"Скорость роста самцов\", \"Скорость роста самок\", \"Разница\"),\n  Значение = c(\n    round(coef(model_male)[\"age\"], 2),\n    round(coef(model_female)[\"age\"], 2),\n    round(delta_beta, 2)\n  ),\n  `p-value` = c(\n    format.pval(summary(model_male)$coefficients[\"age\",4], digits = 2),\n    format.pval(summary(model_female)$coefficients[\"age\",4], digits = 2),\n    format.pval(p_value, digits = 2)\n  )\n)\nkable(comparison_table, caption = \"Сравнение коэффициентов роста\")\n```\n\nВывод\n\n```{r}\n#| output: false\n#| eval: false\n: Сравнение коэффициентов роста\n\n|Параметр              | Значение|p.value |\n|:---------------------|--------:|:-------|\n|Скорость роста самцов |     5.95|<2e-16  |\n|Скорость роста самок  |     4.09|5.2e-13 |\n|Разница               |     1.86|0.00024 |\n> \n```\n\n**Интерпретация:**\\\nЗначимая *разница* (p \\< 0.05) указывает на статистически значимые различия в скорости роста между полами.\n\n### Сравнение моделей\n\nОдним из ключевых аспектов анализа биологических данных является определение формы зависимости между переменными. В данном разделе мы рассмотрим основы подбора модели зависимости между длиной и весом креветок. Начиная с простой линейной модели, мы постепенно перейдем к более сложным нелинейным моделям, чтобы продемонстрировать методику выбора наилучшей модели. Cравним три модели — линейную, полиномиальную и степенную — чтобы определить, какая из них наилучшим образом описывает данные. Цель анализа — найти математическую зависимость, которая:\n\n1.  Точно предсказывает вес креветки по её длине.\n\n2.  Имеет биологическую интерпретацию.\n\n3.  Минимизирует ошибку предсказания.\n\n#### Модели и их параметры\n\n1.  **Линейная**: $\\text{weight} = \\beta_0 + \\beta_1\\cdot\\text{length}$\n2.  **Полиномиальная 3-й степени**: $\\text{weight} = \\beta_0 + \\beta_1\\cdot\\text{length} + \\beta_2\\cdot\\text{length}^2 + \\beta_3\\cdot\\text{length}^3$\n3.  **Степенная**: $\\text{weight} = a\\cdot\\text{length}^b$\n\n#### Метрики\n\n-   **R²** - (коэффициент детерминации): чем ближе к 1, тем лучше модель объясняет данные.\n-   **AIC** -(информационный критерий Акаике): чем меньше значение, тем лучше модель с учётом её сложности.\n\n#### **Результаты**\n\n##### **1. Линейная модель**\n\n```{r}\n#| output: false\n#| eval: false\nCoefficients:\n             Estimate Std. Error t value Pr(>|t|)    \n(Intercept) -2.115      0.085     -24.86   <2e-16 ***\nlength       0.1665     0.0038    43.71    <2e-16 ***\n```\n\n-   **R² = 0.894**\n\n-   **AIC = 148.02**\n\n![Рис. 1.5: Линейная модель](images/linear_shrimp.PNG){fig-align=\"center\" width=\"60%\"}\n\n##### **2. Полиномиальная модель**\n\n```{r}\n#| output: false\n#| eval: false\nCoefficients:\n                 Estimate Std. Error t value Pr(>|t|)    \npoly(length,3)1  14.5038    0.2127    68.18   <2e-16 ***\npoly(length,3)2   3.7209    0.2127    17.49   <2e-16 ***\npoly(length,3)3   0.9526    0.2127     4.48  1.2e-05 ***\n```\n\n-   **R² = 0.957**\n\n-   **AIC = -52.80**\n\n![Рис. 1.5: Полиномиальная модель](images/poly_shrimp.PNG){fig-align=\"center\" width=\"60%\"}\n\n##### **3. Степенная модель**\n\n```{r}\n#| output: false\n#| eval: false\nParameters:\n   Estimate Std. Error t value Pr(>|t|)    \na 0.000157   0.000028    5.60  6.3e-08 ***\nb 2.920160   0.054102   53.98   <2e-16 ***\n```\n\n-   **R² = 0.955**\n\n-   **AIC = -48.43** ![Рис. 1.5: Степенная модель](images/power_shrimp.PNG){fig-align=\"center\" width=\"60%\"}\n\n#### **3. Сравнение моделей**\n\n| **Модель**     | **R²** | **AIC** |\n|:---------------|:-------|:--------|\n| Линейная       | 0.894  | 148.02  |\n| Полиномиальная | 0.957  | -52.80  |\n| Степенная      | 0.955  | -48.43  |\n\n**Выводы:**\n\n1.  **Полиномиальная модель** демонстрирует наилучшие показатели (максимальный R² и минимальный AIC).\n\n2.  **Степенная модель** близка по качеству, но её параметр *b*≈2.92 близок к биологически ожидаемому значению 3 (вес пропорционален объёму).\n\n3.  **Линейная модель** существенно уступает по точности.\n\n#### **4. Рекомендации**\n\n-   **Для прогнозирования** используйте полиномиальную модель, так как она минимизирует ошибку.\n\n-   **Для биологической интерпретации** предпочтительна степенная модель: weight∝length^2.92^.\n\n-   **Избегайте переобучения:** Полиномиальные модели высокой степени могут терять интерпретируемость.\n\n#### **5. Визуализация остатков**\n\nОстатки степенной модели распределены равномерно, что подтверждает её адекватность: ![Рис. 1.5: Остатки](images/residuals_shrimp.PNG){fig-align=\"center\" width=\"60%\"}\n\n#### **Заключение**\n\nДля анализа зависимости веса от длины северной креветки **рекомендуется**:\n\n1.  **Полиномиальная модель** — для задач, требующих максимальной точности.\n\n2.  **Степенная модель** — для интерпретации биологических закономерностей.\n\nСкрипт вышеописанных событий:\n\n```{r}\n#| output: false\n#| eval: false\n# Установка рабочей директории\nsetwd(\"C:/TEXTBOOK/\")\n\n# Загрузка библиотек\nlibrary(tidyverse)\nlibrary(ggplot2)\n\n# Загрузка данных\ndata <- read_csv(\"shrimp_catch.csv\") %>%\n  filter(!id %in% c(10, 50))  # Удаление аномальных наблюдений\n\n# Проверка структуры\nglimpse(data)\n\n# Линейная модель: вес ~ длина\nmodel_linear <- lm(weight ~ length, data = data)\nsummary(model_linear)\n\n# Визуализация\nggplot(data, aes(x = length, y = weight)) +\n  geom_point(color = \"steelblue\", alpha = 0.7) +\n  geom_smooth(method = \"lm\", color = \"#FC4E07\") +\n  labs(title = \"Линейная модель\", x = \"Длина (мм)\", y = \"Вес (г)\")\n\n\n# Полиномиальная модель: вес ~ длина + длина? + длина?\nmodel_poly <- lm(weight ~ poly(length, 3), data = data)\nsummary(model_poly)\n\n# Визуализация\nggplot(data, aes(x = length, y = weight)) +\n  geom_point(color = \"steelblue\", alpha = 0.7) +\n  geom_smooth(method = \"lm\", formula = y ~ poly(x, 3), color = \"#E7B800\") +\n  labs(title = \"Полиномиальная модель\", x = \"Длина (мм)\", y = \"Вес (г)\")\n\n\n# Степенная модель: вес ~ длина^k (k подбирается)\nmodel_power <- nls(weight ~ a * length^b, \n                   data = data, \n                   start = list(a = 0.001, b = 3))  # Начальные значения\nsummary(model_power)\n\n# Визуализация\ndata$pred_power <- predict(model_power)\nggplot(data, aes(x = length, y = weight)) +\n  geom_point(color = \"steelblue\", alpha = 0.7) +\n  geom_line(aes(y = pred_power), color = \"#00BA38\", linewidth = 1.2) +\n  labs(title = \"Степенная модель\", x = \"Длина (мм)\", y = \"Вес (г)\")\n\n# Расчет AIC\nAIC(model_linear, model_poly, model_power)\n\n# Расчет R?\nr2_linear <- summary(model_linear)$r.squared\nr2_poly <- summary(model_poly)$r.squared\nr2_power <- 1 - sum(residuals(model_power)^2) / sum((data$weight - mean(data$weight))^2)\n\n# Создание таблицы сравнения моделей\ncomparison_table <- data.frame(\n  Модель = c(\"Линейная\", \"Полиномиальная\", \"Степенная\"),\n  R_square = c(r2_linear, r2_poly, r2_power),\n  AIC = c(AIC(model_linear), AIC(model_poly), AIC(model_power))\n)\n\n# Вывод таблицы\nprint(comparison_table)\n\n# Остатки для степенной модели\ndata$residuals <- residuals(model_power)\n\nggplot(data, aes(x = length, y = residuals)) +\n  geom_point(color = \"#FC4E07\", alpha = 0.7) +\n  geom_hline(yintercept = 0, linetype = \"dashed\") +\n  labs(title = \"Остатки степенной модели\", x = \"Длина (мм)\", y = \"Ошибка\")\n```\n","srcMarkdownNoYaml":"\n\n## Введение\n\nЭто занятие — про первый шаг в анализе уловов: аккуратно загрузить данные, посмотреть на них без иллюзий и задать простые, проверяемые вопросы. Мы будем работать в R, потому что он честно показывает структуру данных и не скрывает неудобные детали. Наша цель сейчас не «сделать красиво», а убедиться, что мы видим именно то, что реально записано в файле: сколько строк, какие переменные, каких они типов и не прячутся ли среди них ошибки, способные испортить весь последующий анализ.\n\nНачинаем с того, чтобы R «видел» правильную папку. Рабочая директория должна указывать туда, где лежит файл shrimp_catch.csv. Простая установка пути — это не бюрократия, а воспроизводимость: на другом компьютере тот же код должен читать те же данные, а не «что‑то похожее». После этого подключаем tidyverse: это набор инструментов, который унифицирует чтение, преобразование и визуализацию. read_csv считывает таблицу и сразу создаёт tibble — «вежливую» версию data.frame с чётким хранением типов. Уже на этом шаге стоит помнить о банальных, но частых ловушках: десятичный разделитель должен совпадать с вашими региональными настройками, пустые строки и «NA» в файле должны превращаться в пропуски, а не в нули или текст.\n\nПервичный осмотр — это короткий разговор с данными без интерпретации. Команда glimpse выдаёт компактный снимок: сколько строк, каковы названия столбцов и их классы, примеры значений. В нашем наборе ожидаем пять столбцов: id как целое число, age как целое число 1–4, length как числовая величина длины, weight как числовая величина массы и sex как текстовый признак пола. Если вы видите, что length внезапно «chr» или sex закодирован числами — это сигнал остановиться и привести типы в порядок сейчас, а не объяснять странные результаты потом. Аналогичная команда str показывает внутреннюю структуру и подтверждает, что R понимает объект так же, как и вы. Эти две команды — «микроскоп 4×»: быстро и без украшательств.\n\nДальше имеет смысл задать несколько контрольных вопросов, которые одновременно проверяют здравый смысл и раскрывают базовую статистику. summary покажет минимумы, медианы и квартильные точки для количественных переменных и распределение для категориальных. Если где‑то возникает отрицательный вес, нулевая длина или возраст за пределами 1–4 — это не «особенности популяции», это данные, требующие чистки. table и prop.table дадут частоты по полу; если соотношение полов выглядит нереалистично для вашей промысловой выборки — проверьте этап предобработки. Наконец, простой cor.test между длиной и весом покажет, есть ли ожидаемая сильная положительная связь; но здесь важно помнить о дисциплине: корреляция — это не причинность, и даже высокая r требует подтверждения графиком рассеяния и проверкой на аутлаеры.\n\nЗачем столько внимания «мелочам» до любых моделей? Потому что в прикладной биостатистике именно этот участок пути отделяет полезные выводы от красивых, но пустых графиков. Проверка типов и диапазонов, явное обращение с пропусками, подтверждение структурой — это те скромные процедуры, которые экономят часы на поздних этапах. И если позволить себе лёгкую ремарку, то лучший способ повысить интеллектуальную честность анализа — не верить по умолчанию ни себе, ни данным, пока вы не посмотрели на них под простейшим светом glimpse и str.\n\nКогда эти шаги пройдены, можно переходить к описательной статистике и первичной визуализации. Гистограмма длины даст быстрый набросок формы распределения, а простые группировки по возрасту покажут, как меняются средние и разброс. Но это уже следующий раздел. Сейчас важнее, чтобы R и вы одинаково понимали, что такое «наши данные», и чтобы каждый последующий результат опирался на корректно загруженную и проверенную таблицу [shrimp_catch.csv](https://mombus.github.io/cRab/data/shrimp_catch.csv).\n\n## Загрузка данных и первичный осмотр\n\nссылка на файл: [shrimp_catch.csv](https://mombus.github.io/cRab/data/shrimp_catch.csv)\n\n```{r}\n#| output: false\n#| eval: false\n# Установка рабочей директории\nsetwd(\"C:/TEXTBOOK/\")\n# Загрузка библиотек\nlibrary(tidyverse)\n# Загрузка данных\ndata <- read_csv(\"shrimp_catch.csv\")\n\n```\n\nКоманда `glimpse` знакомит со структурой данных:\n\n```{r}\n#| output: false\n#| eval: false\n# Просмотр структуры и первых строк загруженных данных\nglimpse(data)\n```\n\n```{r}\n#| output: false\n#| eval: false\nRows: 230\nColumns: 5\n$ id     <int> 1, 2, 3, 4, 5, 6, 7, 8, 9, 10, 11, 12, 13, 14, 15, 16, 17, 18, ~\n$ age    <int> 2, 4, 4, 4, 1, 4, 2, 2, 4, 3, 4, 3, 2, 1, 2, 1, 2, 2, 2, 2, 3, ~\n$ length <dbl> 20.45450, 25.88928, 29.42257, 30.68292, 12.46059, 28.52152, 17.~\n$ weight <dbl> 1.28221748, 1.97476899, 2.65412595, 3.44746476, 0.13404801, 2.3~\n$ sex    <chr> \"M\", \"F\", \"F\", \"F\", \"M\", \"F\", \"M\", \"M\", \"F\", \"F\", \"F\", \"F\", \"M\"~\n> \n```\n\nМожно использовать команду `str` — показывает внутреннюю **структуру** объекта , включая количество строк, столбцов, названия переменных, их типы (`chr`, `num`, `int` и др.), а также несколько первых значений.\n\n```{r}\n#| output: false\n#| eval: false\nstr(data)\n```\n\n```{r}\n#| output: false\n#| eval: false\n'data.frame':   230 obs. of  5 variables:\n $ id    : int  1 2 3 4 5 6 7 8 9 10 ...\n $ age   : int  2 4 4 4 1 4 2 2 4 3 ...\n $ length: num  20.5 25.9 29.4 30.7 12.5 ...\n $ weight: num  1.282 1.975 2.654 3.447 0.134 ...\n $ sex   : chr  \"M\" \"F\" \"F\" \"F\" ...\n>\n```\n\n## Описательная статистика и визуализация\n\nКоманда `summary` выводит **описательную статистику** для каждой числовой переменной: минимум, 1-й квартиль, медиана, среднее, 3-й квартиль, максимум; для категориальных переменных — частоты.\n\n```{r}\n#| output: false\n#| eval: false\n# Общая статистика\nsummary(data)\n```\n\n```{r}\n#| output: false\n#| eval: false\n       id              age            length          weight       \n Min.   :  1.00   Min.   :1.000   Min.   : 7.65   Min.   :-0.3334  \n 1st Qu.: 58.25   1st Qu.:2.000   1st Qu.:17.62   1st Qu.: 0.6320  \n Median :115.50   Median :3.000   Median :22.49   Median : 1.3660  \n Mean   :115.50   Mean   :2.509   Mean   :21.68   Mean   : 1.4933  \n 3rd Qu.:172.75   3rd Qu.:3.000   3rd Qu.:26.03   3rd Qu.: 2.1148  \n Max.   :230.00   Max.   :4.000   Max.   :36.02   Max.   : 5.1316  \n     sex           \n Length:230        \n Class :character  \n Mode  :character  \n```\n\nПростейшими командами можно вычислить, например, соотоношение полов или корреляцию длина-вес.\n\n```{r}\n#| output: false\n#| eval: false\n# Соотношение полов\nprop.table(table(data$sex)) %>% round(2)\n```\n\n```{r}\n#| output: false\n#| eval: false\n   F    M \n0.35 0.65 \n```\n\n```{r}\n#| output: false\n#| eval: false\n# Корреляция длина-вес с p-value\ncor_test <- cor.test(data$length, data$weight, \n                     method = \"pearson\", \n                     exact = FALSE,\n                     na.action = na.omit)\n \ncor_coef <- round(cor_test$estimate, 2)\np_value <- scales::pvalue(cor_test$p.value, accuracy = .001)\n \ncat(\"Корреляция Пирсона: r =\", cor_coef, \", p =\", p_value, \"\\n\")\n```\n\n```{r}\n#| output: false\n#| eval: false\nКорреляция Пирсона: r = 0.95 , p = <0.001 \n```\n\n```{r}\n#| output: false\n#| eval: false\n# Распределение возраста\ntable(data$age)\n```\n\n```{r}\n#| output: false\n#| eval: false\n1  2  3  4 \n43 68 77 40 \n```\n\n```{r}\n#| output: false\n#| eval: false\n# Средние значения длины и веса по группам\ndata %>%\n   group_by(age) %>%\n   summarise(\n     mean_length = mean(length),\n     sd_length = sd(length),\n     mean_weight = mean(weight),\n     sd_weight = sd(weight))\n```\n\n```{r}\n#| output: false\n#| eval: false\n# A tibble: 4 x 5\n    age mean_length sd_length mean_weight sd_weight\n  <dbl>       <dbl>     <dbl>       <dbl>     <dbl>\n1     1        12.7      1.37       0.249     0.234\n2     2        19.2      1.88       0.919     0.341\n3     3        24.8      1.72       1.88      0.424\n4     4        29.1      2.28       2.96      0.804\n> \n\n```\n\n### Построение гистограммы для переменной 'length' (длина креветок)\n\nДля первого визуального знакомства команда `hist` строит гистограмму — простой график, который показывает, как распределены значения числовой переменной. В данном случае отображается распределение длин креветок из набора данных.\n\n```{r}\n#| output: false\n#| eval: false\nhist(data$length, \n     main = \"Гистограмма длины креветок\",          # Заголовок графика\n     xlab = \"Длина (см)\",                          # Подпись оси X\n     ylab = \"Частота\",                             # Подпись оси Y\n     col = \"lightblue\",                            # Цвет столбцов\n     border = \"black\",                             # Цвет границ столбцов\n     breaks = 15)                                   # Количество интервалов\n```\n\n![Рис. 1.1: Гистограмма длины креветок](images/hist_shrimp.PNG){fig-align=\"center\" width=\"60%\"}\n\n### Визуализация в `ggridges`\n\nДля элегантных и компактных графиков подходит библиотека `ggridges`. Построим распределение длины креветки в зависимости от пола и возраста.\n\n```{r}\n#| output: false\n#| eval: false\nlibrary(ggplot2)\nlibrary(ggridges)\n\nggplot(data, aes(x = length, \n                 y = sex, \n                 group = sex, \n                 fill = sex)) +\n  geom_density_ridges(scale = 2, alpha = 0.7) +\n  scale_y_discrete(expand = c(0, 0)) +\n  scale_x_continuous(expand = c(0, 0)) +\n  labs(\n    title = \"Распределение длины карапакса по полу\",\n    x = \"Длина карапакса (мм)\",\n    y = \"Пол\"\n  ) +\n  theme(\n    panel.border = element_blank(),  # Убирает рамку вокруг графика\n    axis.line = element_line(color = \"black\")  # Сохраняет осевые линии (опционально)\n  )\n\n```\n\n![Рис. 1.2: Пол-длина креветок с использованием `ggridges`](images/ggridges_shrimp.PNG){fig-align=\"center\" width=\"60%\"}\n\n## Выявление аутлайеров (выбросов)\n\nАутлаеры (выбросы) — наблюдения, значительно отклоняющиеся от общего распределения данных. Их идентификация критически важна, так как они могут искажать результаты анализа. Один из надёжных методов обнаружения выбросов — **метод межквартильного размаха (IQR)**.\n\n### **Теория метода**\n\n1.  **Расчёт квартилей**:\n\n    -   **Q1** (25-й перцентиль): значение, ниже которого находится 25% данных.\n\n    -   **Q3** (75-й перцентиль): значение, ниже которого находится 75% данных.\n\n    -   **IQR = Q3 - Q1**: мера разброса средней половины данных.\n\n2.  **Границы аутлаеров**:\n\n    -   **Нижняя граница**: Q1−1.5×IQRQ1−1.5×IQR\n\n    -   **Верхняя граница**: Q3+1.5×IQRQ3+1.5×IQR\\\n        Наблюдения за этими пределами считаются выбросами.\n\n### **Преимущества метода**\n\n-   Устойчивость к асимметрии распределения.\n\n-   Не требует предположения о нормальности данных.\n\n```{r}\n#| output: false\n#| eval: false\n\n# Метод межквартильного размаха\noutliers <- data %>%\n  mutate(\n    length_z = scale(length),\n    weight_z = scale(weight)\n  ) %>% \n  filter(abs(length_z) > 3 | abs(weight_z) > 3)\n\n# Визуализация\nggplot(data, aes(x = length, y = weight)) +\n  geom_point(aes(color = \"Обычные\"), alpha = 0.5) +\n  geom_point(data = outliers, aes(color = \"Аутлаеры\"), size = 3) +\n  scale_color_manual(values = c(\"Обычные\" = \"grey50\", \"Аутлаеры\" = \"red\")) +\n  labs(title = \"Выявление аномальных наблюдений\", color = \"Тип\")\n```\n\n![Рис. 1.3: Распределение длины карапакса](images/outliers_shrimp.PNG){fig-align=\"center\" width=\"60%\"}\n\n## Определение возрастной структуры: статистические методы анализа размерных данных\n\n**Лирическое отступление**\n\nОпределять возрастную структуру по размерным данным — это не попытка «угадать» возраст, а дисциплинированный способ выделить в общей смеси несколько закономерных мод, за которыми почти всегда стоят биологические процессы: вариации в пополнении, различия в темпах роста, селективность промысла. Мы не видим возраст напрямую, зато видим след его накопления в длине, и задача статистики здесь — разложить смешанное распределение на осмысленные компоненты, не выдавая желаемое за действительное. Начинать разумно с простого: гистограмма и сглаженная плотность дают первичную картину, где «пики» — это кандидаты на возрастные группы. Выбор ширины бинов (диапазонов) — не косметика: слишком широкие бины сливают моды, слишком узкие создают шумовые «зубцы». Ядерная плотность полезна как независимая проверка: если пик виден и на гистограмме, и на сглаженной плотности, это хороший знак. Уже на этом шаге важно исключить явные аутлаеры и убедиться, что анализируется однородная по сезону и району выборка: смешение сезонов способно превратить один чёткий пик в два слабых и наоборот.\n\nK‑means привлекателен скоростью и простотой, но его допущения жестковаты для биологии: он делит по ближайшему центру и фактически предполагает равные дисперсии у групп. Для черновой разметки это приемлемо: задали *K*, получили кластеры, посмотрели, не распилили ли явный пик пополам и не смешали ли крайние хвосты. Но трактовать эти кластеры как «возрастные классы» без дополнительных проверок нельзя. Минимальный набор проверок — «локальный смысл»: центры кластеров должны быть упорядочены по длине, доли групп не должны выглядеть абсурдно для вашей системы, а границы между кластерами — приходиться на спады между модами гистограммы. Полезно пробежать несколько значений *K*, посмотреть «локоть» по внутрикластерной дисперсии или силуэт; если модель жадно «доедает» шум, она не помогает задаче.\n\nДекомпозиция смесью нормалей с EM‑алгоритмом ближе к тому, что нам нужно: каждая компонента имеет свой средний размер, свою дисперсию и свою долю, а принадлежность особи — вероятностная, а не «жёсткая». Это лучше отражает реальность: возрастные группы перекрываются, и жёсткое отнесение на границе избыточно уверенно. Здесь ключевая инженерная мысль — инициализация и выбор числа компонент. Стартовать можно от пиковой структуры гистограммы или от грубых центров k‑means; число компонент выбирать по BIC/AIC и здравому смыслу, помня, что каждая лишняя компонента почти всегда «объясняет» шум. Параметры смеси имеют прозрачную интерпретацию: *μ* — модальный размер группы, *σ* — разброс (ростовая гетерогенность плюс измерительная ошибка), *λ* — доля группы в выборке. Для отчётности полезно ранжировать компоненты по μ, чтобы избежать «перескока меток» между запусками, и дать доверительные интервалы (обычный приём — бутстрэп).\n\nМетод Бхаттачарии, классика промысловой статистики, по сути делает то же в терминах гистограммы: линейнизует лог‑разности соседних бинов и позволяет визуально «вынуть» наклон, соответствующий компоненте нормального распределения. Он чувствителен к выбору ширины бина и к ровности хвостов, зато нагляден и хорошо работает там, где пики действительно нормальны и отделены. В паре с EM это сильная связка: Бхаттачария помогает выбрать разумное *K* и старт, EM — уточняет параметры и даёт вероятностные принадлежности. Сопоставление результатов этих двух подходов повышает доверие: если оба «видят» четыре группы с близкими μ, это гораздо лучше, чем красивый рисунок одного метода.\n\nНа практике полезно придерживаться алгоритма «снизу вверх». Сначала — чистая визуализация: гистограмма, ядерная плотность, по возможности разрезы по полу и возрасту полевой маркировки; это помогает понять, не смешиваем ли мы биологически разные контексты. Затем — черновая кластеризация k‑means для ориентировочных центров и грубого *K*. Далее — смеси нормалей с EM, выбор *K* по BIC и проверка стабильности решения от разных стартов. После подгонки — диагностика: наложить компоненты и суммарную смесь на гистограмму, проверить, не «улетели» ли *σ*, нет ли «дублирующих» компонент с почти одинаковыми *μ*, сопоставить *λ* с ожидаемыми долями когорт. И главное — помнить, что «модальные группы по длине» и «возрастные классы» совпадают не автоматом: для перевода мод в возраст нужен ростовой ключ (например, параметры Берталанфи) или независимая информация о когортности. Без этого честнее говорить «модальные размерные группы».\n\nНаконец, стоит держать в голове пару дисциплинарных напоминаний. Любая смесь будет пытаться объяснить артефакты данных, поэтому контроль качества измерений и фильтрация аутлаеров — не опция, а необходимость. Сезонная выборка и выборочная выловленность сдвигают доли и средние: если орудия ловят неравномерно, *λ* смеси — это не «структура популяции», а «структура улова». И, как бы прозаично это ни звучало, фиксируйте зерно генератора случайных чисел и документируйте выбор *K* и стартовые значения: это делает ваш результат воспроизводимым, а спор — предметным. Такой дисциплинированный ход — от картинки к модели, от модели к диагностике, от диагностики к осторожной интерпретации — позволяет извлечь из длины то, что она действительно хранит про возраст, и не больше.\n\nИ так, возрастная структура популяции — часто важна для расчёта промысловой смертности, оценки репродуктивного потенциала и прогнозирования динамики запасов. Поскольку прямое измерение возраста часто невозможно (например, у беспозвоночных или рыб без четких возрастных меток), используются статистические методы, выделяющие группы в смешанных распределениях размеров.\n\n**Основные подходы:**\n\n1.  **Метод k-средних (k-means)** — алгоритм кластеризации, группирующий особи в заданное число кластеров (возрастных групп) на основе их размеров.\n\n2.  **Метод Бхаттачарии** — статистический подход для разделения смешанных нормальных распределений, часто применяемый для идентификации мод в гистограммах.\n\n3.  **EM-алгоритм** — оценка параметров смеси распределений, подходящая для данных с перекрывающимися возрастными группами.\n\n4.  **Гауссовы смеси (GMM)** — расширение метода Бхаттачарии для многомерного анализа.\n\n5.  **Ядерное сглаживание** — непараметрический метод визуализации плотности, помогающий выявить скрытые моды.\n\nРассмотрим метод k-средних (k-means) и метод Бхаттачарии, предварительно построив гистограмму.\n\n```{r}\n#| output: false\n#| eval: false\n\n# Загрузка библиотек\nlibrary(tidyverse)\nlibrary(mixtools)\n# Гистограмма длины с наложением плотности\nggplot(data, aes(x = length)) +\n  geom_histogram(aes(y = after_stat(density)), fill = \"steelblue\", bins = 20, alpha = 0.7) +\n  geom_density(color = \"#FC4E07\", linewidth = 1) +\n  labs(title = \"Распределение длины карапакса\", \n       subtitle = \"Пики могут соответствовать возрастным группам\",\n       x = \"Длина (мм)\")\n```\n\n![Рис. 1.3: Распределение длины карапакса](images/hist_dens_shrimp.PNG){fig-align=\"center\" width=\"60%\"}\n\n```{r}\n#| output: false\n#| eval: false\n# Кластеризация по длине (K-means как пример)\nset.seed(123)\nclusters <- kmeans(data$length, centers = 4)  # Предполагаем 4 возрастные группы\ndata$cluster <- factor(clusters$cluster)\n\n# Визуализация кластеров\nggplot(data, aes(x = length, fill = cluster)) +\n  geom_histogram(bins = 25, alpha = 0.7) +\n  labs(title = \"Кластеризация по длине)\", \n       x = \"Длина (мм)\")\n```\n\n![Рис. 1.4: Кластеризация по длине](images/cluster_shrimp.PNG){fig-align=\"center\" width=\"60%\"}\n\n```{r}\n#| output: false\n#| eval: false\n# Установка рабочей директории\nsetwd(\"C:/TEXTBOOK/\")\n\n# Загрузка библиотек\nlibrary(tidyverse)\nlibrary(mixtools)\n\n# Загрузка данных\ndata <- read.csv(\"shrimp_catch.csv\")\n\n# 1. Построение и отображение гистограммы\nhist(data$length, breaks = 20, main = \"Гистограмма распределения длин карапаксов\",\n     xlab = \"Длина карапакса (мм)\", ylab = \"Частота\")\n\n# 2. Инициализация параметров (предположим 4 возрастные группы)\ninit_params <- list(\n  lambda = rep(1/4, 4),\n  mu = c(13, 19, 25, 32),\n  sigma = c(1.5, 1.75, 1.75, 2.5)\n)\n\n# 3. Разделение смеси распределений методом EM\nfit <- normalmixEM(data$length, k = 4, maxit = 1000, epsilon = 1e-3,\n                   lambda = init_params$lambda,\n                   mu = init_params$mu,\n                   sigma = init_params$sigma)\n\n# 4. Визуализация результатов с ggplot2\n# Генерация сетки для построения кривых\nx_grid <- seq(min(data$length), max(data$length), length.out = 500)\n\n# Функция смеси\nmixture_density <- function(x) {\n  fit$lambda[1] * dnorm(x, fit$mu[1], fit$sigma[1]) +\n  fit$lambda[2] * dnorm(x, fit$mu[2], fit$sigma[2]) +\n  fit$lambda[3] * dnorm(x, fit$mu[3], fit$sigma[3]) +\n  fit$lambda[4] * dnorm(x, fit$mu[4], fit$sigma[4])\n}\n\n# График\nggplot(data, aes(x = length)) +\n  # Гистограмма\n  geom_histogram(aes(y = after_stat(density)), bins = 20, fill = \"white\", color = \"black\", alpha = 0.7) +\n  # Исходное распределение (гладкая линия)\n  geom_density(color = \"red\", lwd = 1.2) +\n  # Смесь распределений\n  stat_function(fun = mixture_density, color = \"black\", lwd = 1.5) +\n  # Компоненты смеси\n  stat_function(fun = function(x) fit$lambda[1] * dnorm(x, fit$mu[1], fit$sigma[1]), color = \"blue\", lwd = 1) +\n  stat_function(fun = function(x) fit$lambda[2] * dnorm(x, fit$mu[2], fit$sigma[2]), color = \"green\", lwd = 1) +\n  stat_function(fun = function(x) fit$lambda[3] * dnorm(x, fit$mu[3], fit$sigma[3]), color = \"orange\", lwd = 1) +\n  stat_function(fun = function(x) fit$lambda[4] * dnorm(x, fit$mu[4], fit$sigma[4]), color = \"purple\", lwd = 1) +\n  \n  # Настройка темы и легенды\n  theme_minimal() +\n  labs(\n    x = \"Длина карапакса (мм)\",\n    y = \"Плотность\",\n    title = \"Разделение возрастных групп методом EM\"\n  )\n```\n\n![Рис. 1.5: Метод Бхаттачарии](images/bhattacharya_shrimp.PNG){fig-align=\"center\" width=\"60%\"}\n\n## Уравнение Берталанфи\n\nУравнение Берталанфи — фундаментальная модель в рыбохозяйственной науке, описывающая асимптотический рост организмов. Оно имеет вид: $$\nL(t) = L_{\\infty} \\cdot \\left(1 - e^{-k \\cdot (t - t_0)}\\right)\n$$ где *L~∞~*— теоретическая максимальная длина особи, *k*— коэффициент скорости роста, *t~0~*— гипотетический возраст при нулевой длине.\n\nВ приведённом коде модель применяется для анализа роста северной креветки :\n\n1.  **Подготовка данных**: Удаление аутлаеров (например, строк 10 и 50) повышает точность оценки параметров.\n\n2.  **Инициализация параметров**:\n\n    -   *L~∞~* задаётся как максимальная наблюдаемая длина в данных.\n\n    -   *k* и *t~0~* подбираются итеративно методом нелинейных наименьших квадратов (**`nls`**).\n\n3.  **Визуализация**: График сопоставляет эмпирические данные (точки) с предсказаниями модели (красная линия), демонстрируя, как рост замедляется с приближением к *L∞*.\n\n**Интерпретация параметров**:\n\n-   Высокое значение *k* (\\>0.3) указывает на быстрый рост молоди.\n\n-   *t~0~*\\<0 может отражать ранний метаморфоз личинок.\n\n```{r}\n#| output: false\n#| eval: false\n# Загрузка библиотек\nlibrary(ggplot2)\nlibrary(dplyr)\nlibrary(nlme)\n\n# Загрузка данных\ndata <- read.csv(\"shrimp_catch.csv\")\n\n# Преобразование возраста в числовой формат\ndata$age_num <- as.numeric(data$age)\n\n# Удаление аутлайеров (если необходимо)\ndata_clean <- data %>%\n  filter(!id %in% c(10, 50))  # Пример удаления строк с аномалиями\n\n# Начальные параметры на основе данных\nL_inf_start <- max(data_clean$length, na.rm = TRUE)  # Максимальная длина\nk_start <- 0.3                                        # Средняя скорость роста\nt0_start <- -0.5                                      # Гипотетический возраст\n\n# Подгонка модели с увеличенным числом итераций\nmodel <- nls(\n  length ~ L_inf * (1 - exp(-k * (age_num - t0))),\n  data = data_clean,\n  start = list(L_inf = L_inf_start, k = k_start, t0 = t0_start),\n  control = nls.control(maxiter = 200, warnOnly = TRUE)  # Увеличиваем лимит итераций\n)\n\n# Вывод результатов\nsummary(model)\n\n# Создание последовательности возрастов для предсказания\nage_seq <- seq(min(data_clean$age_num), max(data_clean$age_num), by = 0.1)\n\n# Предсказание значений длины\nlength_pred <- predict(model, newdata = data.frame(age_num = age_seq))\n\n# Построение графика\nggplot(data_clean, aes(x = age_num, y = length)) +\n  geom_point(aes(color = age), alpha = 0.7) +\n  geom_line(data = data.frame(age_num = age_seq, length = length_pred), \n            aes(x = age_num, y = length), color = \"red\", linewidth = 1.2) +\n  labs(\n    title = \"Рост креветок по уравнению Берталанфи\",\n    x = \"Возраст (годы)\",\n    y = \"Длина карапакса (мм)\",\n    color = \"Возрастная группа\"\n  ) +\n  theme_minimal()\n\n# Сохранение графика\nggsave(\"bertalanffy_model.png\", width = 8, height = 6)\n```\n\n![Рис. 1.6: Рост креветок по уравнению Берталанфи](images/bertalanffy_model.PNG){fig-align=\"center\" width=\"60%\"}\n\n## Огива, логистическая кривая и 50%-ное созревание\n\nЛогистическая регрессия удобна там, где исход — бинарный: созрел/не созрел, самка/самец. Для протоандрической креветки вероятность быть самкой естественно растёт с длиной, и логистическая кривая описывает это гладким переходом от 0 к 1; её центральная точка даёт L50 = −β0/β1 — длину, при которой половина особей уже самки. Огива — это та же история, но накопительно: как доля самок нарастает по мере увеличения длины; она наглядна для сравнения годов/районов и проверки сдвигов зрелости. Качество модели удобно проверять ROC/AUC: AUC ≈ 0.9+ означает, что длина хорошо ранжирует вероятность женского пола, но не отменяет проверки калибровки. Знак и величина β1 интерпретируются просто: положительный β1 — с каждым миллиметром шансы быть самкой растут, exp(β1) — во сколько раз растут эти шансы на единицу длины. Биологически L50 концентрирует ключевой сигнал: при стабильных условиях он держится в узком интервале (для *Pandalus borealis* около 25–28 мм), а его снижение обычно маркирует стресс среды или избирательный вылов, «подталкивающий» к более раннему созреванию. В прикладном учёте это даёт два практичных числа — L50 и AUC — и две опоры для интерпретации: насколько резко идёт переход (крутизна кривой) и насколько надёжен прогноз (дискриминация и калибровка).\n\nЛогистическая кривая — ключевой инструмент для моделирования бинарных процессов, таких как созревание или смена пола у организмов. В случае протоандрических креветок (*Pandalus borealis*), которые меняют пол с возрастом, зависимость вероятности быть самкой от длины карапакса можно описать логистической функцией:\n\n$$\nP(F) = \\frac{1}{1 + e^{-(\\beta_0 + \\beta_1 \\cdot длина)}}\n$$\n\nгде *P(F)* — вероятность принадлежности к женскому полу, *β~0~* — интерсепт, *β~1~* — коэффициент влияния длины.\n\nТочка перегиба логистической кривой соответствует длине, при которой вероятность быть самкой равна 50%: $$\nL_{50} = -\\frac{\\beta_0}{\\beta_1}\n$$\n\n![Рис. 1.7: Логистическая кривая](images/logistic_model_shrimp.PNG){fig-align=\"center\" width=\"60%\"}\n\nОгива (кумулятивная кривая) показывает накопление вероятности с увеличением длины. Для анализа созревания её можно построить через интеграл логистической функции. Визуально она демонстрирует, как доля самок возрастает с размером.\n\n![Рис. 1.8: Огива](images/ogive_shrimp.PNG){fig-align=\"center\" width=\"60%\"}\n\n### **Оценка модели**\n\n1.  **ROC-кривая и AUC**:\n\n    -   Площадь под ROC-кривой (AUC) \\>0.7 указывает на хорошую предсказательную способность модели.\n\n    -   Значение AUC = 0.94(пример из кода) подтверждает сильную связь длины и пола.\n\n![Рис. 1.9: ROC-кривая и AUC](images/ROC_shrimp.PNG){fig-align=\"center\" width=\"60%\"}\n\n2.  **Интерпретация коэффициентов**:\n\n    -   Положительный *β~1~* означает: с ростом длины вероятность быть самкой увеличивается.\n\n    -   Например, *β~1~*=0.25 → увеличение длины на 1 мм повышает шансы в e^0.25^≈1.28 раза.\n\n### **Биологический контекст**\n\n-   **Протоандрический гермафродитизм**: У креветок смена пола с самцов на самок происходит при достижении критического размера (\\~25-28 мм).\n\n-   **L50 как индикатор**: Снижение *L~50~* в популяции может сигнализировать о стрессовых условиях (перелов, изменение среды), ускоряющих созревание.\n\n```{r}\n#| output: false\n#| eval: false\n# Установка рабочей директории\nsetwd(\"C:/TEXTBOOK/\")\n\n# Загрузка библиотек\nlibrary(tidyverse)\nlibrary(pROC)\nlibrary(ggplot2)\n\n# Загрузка данных\ndata <- read_csv(\"shrimp_catch.csv\")\n\n# 1. Предобработка данных -----------------------------------------------------\n# Удаление аутлаеров методом IQR\nQ1 <- quantile(data$length, 0.25)\nQ3 <- quantile(data$length, 0.75)\nIQR <- Q3 - Q1\ndata_clean <- data %>%\n  filter(length >= Q1 - 1.5*IQR & length <= Q3 + 1.5*IQR)\n\n# 2. Логистическая регрессия --------------------------------------------------\n# Преобразование пола в бинарную переменную\ndata_clean$sex_binary <- ifelse(data_clean$sex == \"F\", 1, 0)\n\n# Подгонка модели\nmodel_logit <- glm(sex_binary ~ length, \n                   data = data_clean, \n                   family = binomial(link = \"logit\"))\n\n# Расчет коэффициентов\nbeta0 <- coef(model_logit)[1]\nbeta1 <- coef(model_logit)[2]\n\n# Вычисление L50 (длина 50% созревания)\nL50 <- round(-beta0/beta1, 1)\n\n# 3. Визуализация ------------------------------------------------------------\n# Логистическая кривая\nggplot(data_clean, aes(x = length, y = sex_binary)) +\n  geom_point(aes(color = sex), alpha = 0.6, size = 2) +\n  geom_line(aes(y = predict(model_logit, type = \"response\")), \n            color = \"#D81B60\", linewidth = 1.5) +\n  geom_vline(xintercept = L50, linetype = \"dashed\", color = \"#1E88E5\") +\n  annotate(\"text\", x = L50 + 2, y = 0.2, \n           label = paste(\"L50 =\", L50, \"мм\"), color = \"#1E88E5\") +\n  scale_color_manual(values = c(\"#FFC107\", \"#1976D2\")) +\n  labs(\n    title = \"Зависимость пола от длины карапакса\",\n    subtitle = \"Логистическая регрессия с 50%-ной точкой созревания\",\n    x = \"Длина карапакса (мм)\",\n    y = \"Вероятность быть самкой (P(F))\"\n  ) +\n  theme_minimal(base_size = 12)\n\n# Огива (кумулятивное распределение)\ndata_ogive <- data_clean %>%\n  arrange(length) %>%\n  mutate(\n    cum_females = cumsum(sex_binary),\n    cum_prob = cum_females / max(cum_females)\n  )\n\nggplot(data_ogive, aes(x = length, y = cum_prob)) +\n  geom_line(color = \"#4CAF50\", linewidth = 1.5) +\n  geom_vline(xintercept = L50, linetype = \"dashed\", color = \"#1E88E5\") +\n  geom_hline(yintercept = 0.5, linetype = \"dotted\", color = \"#757575\") +\n  annotate(\"text\", x = L50 + 2, y = 0.55, \n           label = paste(\"50% созревание при\", L50, \"мм\"), color = \"#1E88E5\") +\n  scale_y_continuous(labels = scales::percent) +\n  labs(\n    title = \"Огива: Кумулятивное распределение самок\",\n    x = \"Длина карапакса (мм)\",\n    y = \"Накопленная доля самок\"\n  ) +\n  theme_minimal(base_size = 12)\n\n# 4. Оценка модели -----------------------------------------------------------\n# ROC-анализ\nroc_obj <- roc(data_clean$sex_binary, predict(model_logit, type = \"response\"))\nauc_value <- round(auc(roc_obj), 2)\n\n# График ROC-кривой\nplot(roc_obj, col = \"#E53935\", main = paste(\"ROC-кривая (AUC =\", auc_value, \")\"))\n\n# 5. Сохранение результатов --------------------------------------------------\nggsave(\"logistic_curve.png\", width = 8, height = 6, dpi = 300)\nggsave(\"ogive_curve.png\", width = 8, height = 6, dpi = 300)\n\n# Вывод ключевых метрик\ncat(\"Результаты анализа:\\n\")\ncat(\"- Длина 50%-ного созревания (L50):\", L50, \"мм\\n\")\ncat(\"- AUC модели:\", auc_value, \"\\n\")\ncat(\"- Коэффициенты модели:\\n\")\ncat(\"  Intercept (β0):\", round(beta0, 2), \"\\n\")\ncat(\"  Slope (β1):\", round(beta1, 2), \"\\n\")\n```\n\n## Сравнение групп, параметров, моделей\n\nСравнивать группы — это не про охоту за маленькими p-value, а про проверяемые ответы на конкретные биологические вопросы. «Самки длиннее самцов?» — переводим в аккуратную статистическую формулировку, начинаем с гигиены данных и только потом подбираем тест. Предобработка банальна, но критична: убираем очевидные аутлаеры по понятному правилу (IQR или заранее согласованный протокол), не «чистим» хвосты до совершенства, сохраняем независимость наблюдений. Разбиваем выборку на подмножества по полу, проверяем типы переменных, смотрим на формы распределений и пропуски. И дальше — не прыжок к t‑тесту, а короткая остановка у предпосылок: нормальность и гомогенность дисперсий — это про остатки и разумность аппроксимации, а не про «магическое число 0.05». При несхожих дисперсиях уместнее Уэлч, при явной ненормальности и неробастности — Манн–Уитни, а при больших n классический t‑тест часто держится благодаря центральной предельной теореме. В любом случае голые p‑значения не заканчивают разговор: эффект размера (Cohen’s d) и доверительные интервалы говорят «на сколько», а не только «есть/нет».\n\nВизуализация в этом месте — не иллюстрация, а часть доказательства. Boxplot/violin помогают увидеть медианы, разброс и асимметрию; добавленная на график оценка p‑value дисциплинирует интерпретацию, но не подменяет её. Полезно в той же системе координат показать точки, чтобы помнить: каждая точка — отдельная особь, а не абстрактная «генеральная совокупность». И если позволить себе короткую «сапольскину» ремарку: мозг с удовольствием «видит» разницу там, где её нет, поэтому лучше сначала смотреть на график, потом на число, а не наоборот.\n\nКогда вопрос — уже не «кто крупнее», а «кто растёт быстрее», сравнение средних сменяется сравнением параметров модели. Самый прозрачный путь — объединённая линейная модель с взаимодействием: length \\~ age \\* sex. Значимый коэффициент при взаимодействии — это формализованная фраза «наклоны различаются». Диагностика здесь важнее, чем когда‑либо: линейность, разброс остатков, потенциальные leverage‑точки. Альтернатива — раздельные модели по полу и прямое сравнение наклонов через тест Вальда; он удобен как независимая проверка и часто даёт те же выводы, что и взаимодействие, если структура данных не экзотична. Интерпретация должна оставаться биологической: различающиеся наклоны — это не «магия пола», а потенциальная разница в темпе роста, доступе к корму или сезоне отбора проб.\n\nДальше мы неизбежно приходим к форме связи «вес–длина». Линейная модель соблазнительно проста, но биологически мир чаще степенной: масса масштабируется примерно как длина в степени 3, с поправками на форму и состояние. Полиномиальная регрессия третьего порядка часто выигрывает в AIC и R², потому что ловит сгибы и плечи; у неё есть и оборотная сторона — склонность к переобучению и слабая интерпретируемость коэффициентов. Степенная модель почти всегда немного проигрывает по «сухим метрикам», зато даёт ясный смысл: параметр b близок к 3 — всё ожидаемо; заметное отклонение — есть предмет для обсуждения физиологии, питания, сезонности. Какой из подходов «лучший»? Тот, у которого остатки ведут себя прилично, AIC не кричит о лишней сложности, а биолог рассказывает связную историю, не пряча глаза. Хорошая практика — сопоставить все три, показать таблицу R²/AIC, приложить графики остатков и проговорить компромисс между точностью и объяснимостью.\n\nИ в сравнении групп, и в сравнении параметров, и в выборе модели действуют три простых правила. Первое — формулируйте вопрос до теста: это экономит десятки необязательных проверок. Второе — показывайте эффект с интервалами: «на сколько» важнее «насколько значимо». Третье — проверяйте устойчивость: замены теста (t ↔ Уэлч ↔ Манн–Уитни), альтернативная спецификация модели, бутстрэп интервалов — всё это помогает отличить сигнал от удачного совпадения. И, наконец, не забывайте про контекст отбора проб: если улов по орудиям и глубинам неоднороден, то и выводы про «среднего самца» или «типичную самку» легко превращаются в выводы про «типичный улов». Статистическая аккуратность здесь — это не педантизм, а способ говорить о биологии без самообмана.\n\n### Сравнение групп (на примере самцов и самок)\n\nРассмотрим методы сравнения количественных характеристик (длина, вес) между самцами и самками северной креветки. Анализ включает проверку нормальности распределения, выбор подходящего статистического теста и визуализацию различий.\n\n#### Подготовка данных\n\nЗагрузим данные и выделим подвыборки для самцов и самок:\n\n```{r}\n#| output: false\n#| eval: false\n# Установка рабочей директории\nsetwd(\"C:/TEXTBOOK/\")\n\n# Загрузка библиотек  \nlibrary(tidyverse)  \nlibrary(ggplot2)  \nlibrary(rstatix)\nlibrary(ggpubr)\n\n# Загрузка данных  \ndata <- read_csv(\"shrimp_catch.csv\") %>%\n  filter(!id %in% c(10, 50))  # Удаление аномальных наблюдений \n\n# Фильтрация данных по полу  \nmales <- data %>% filter(sex == \"M\")  \nfemales <- data %>% filter(sex == \"F\") \n```\n\n#### Проверка нормальности распределения\n\nПеред сравнением групп проверим, соответствуют ли данные нормальному распределению (тест Шапиро-Уилка):\n\n```{r}\n#| output: false\n#| eval: false\n# Проверка нормальности для длины самцов  \nshapiro_test(males$length)  \n# Проверка нормальности для длины самок  \nshapiro_test(females$length) \n```\n\nЕсли p-value \\> 0.05, распределение считается нормальным. В противном случае используем непараметрические методы.\n\n#### Сравнение средних значений\n\nЕсли данные нормальны: t-тест\n\n```{r}\n#| output: false\n#| eval: false\n# T-тест для сравнения длин самцов и самок  \nt_test_result <- t_test(length ~ sex, data = data)  \nt_test_result \n```\n\nЕсли данные не нормальны: U-тест Манна-Уитни\n\n```{r}\n#| output: false\n#| eval: false\n# U-тест для сравнения длин самцов и самок  \nmannwhitney_result <- wilcox_test(length ~ sex, data = data)  \nmannwhitney_result \n```\n\n#### Эффект размера (коэффициент Коэна)\n\nДля оценки практической значимости различий рассчитаем коэффициент Коэна:\n\n```{r}\n#| output: false\n#| eval: false\n# Расчет коэффициента Коэна  \ncohens_d_result <- cohens_d(length ~ sex, data = data)  \ncohens_d_result  \n```\n\n-   **d \\< 0.2** : малый эффект,\n\n-   **d ≈ 0.5** : средний эффект,\n\n-   **d \\> 0.8** : большой эффект.\n\n#### **Визуализация различий**\n\nПостроим boxplot для визуального сравнения длин самцов и самок:\n\n```{r}\n#| output: false\n#| eval: false\nggplot(data, aes(x = sex, y = length, fill = sex)) +  \n  geom_boxplot(color = \"black\", alpha = 0.7) +  \n  stat_compare_means(method = \"t.test\") +  # Добавление p-value  \n  labs(title = \"Сравнение длин самцов и самок\",  \n       x = \"Пол\", y = \"Длина карапакса (мм)\") +  \n  theme_minimal() \n```\n\n![Рис. 1.10: Boxplot сравнения длин самцов и самок](images/ttest_shrimp.PNG){fig-align=\"center\" width=\"60%\"}\n\n#### **Интерпретация результатов**\n\n1.  Если p-value \\< 0.05, различия между группами статистически значимы.\n\n2.  Эффект размера помогает оценить биологическую важность различий. Например, если самки значительно крупнее самцов (d = 1.2), это может указывать на половой диморфизм, связанный с репродуктивной стратегией.\n\n    #### **Пример полного анализа для веса**\n\n```{r}\n#| output: false\n#| eval: false\n# Полный анализ для веса  \nweight_analysis <- data %>%  \n  group_by(sex) %>%  \n  summarise(  \n    mean_weight = mean(weight),  \n    sd_weight = sd(weight),  \n    n = n()  \n  ) %>%  \n  mutate(  \n    t_test = list(t_test(weight ~ sex, data = data)),  \n    cohens_d = list(cohens_d(weight ~ sex, data = data))  \n  )  \n\n# Вывод результатов  \nprint(weight_analysis) \n\n# Распределение веса по полу\nggplot(data, aes(x = factor(sex), y = weight, fill = factor(sex))) +\n  geom_violin(trim = FALSE, alpha = 0.7) +\n  geom_boxplot(width = 0.2, outlier.shape = NA, fill = \"white\") +\n  labs(title = \"Распределение веса по полу\", x = \"Пол\", y = \"Вес (г)\") +\n  theme_minimal()\n```\n\n![Рис. 1.12: Violin plot для визуализации распределения веса](images/violin_shrimp.PNG){fig-align=\"center\" width=\"60%\"}\n\n#### **Выводы**\n\n1.  Используйте t-тест для нормальных данных и U-тест для ненормальных.\n\n2.  Дополните анализ оценкой эффекта размера для биологической интерпретации.\n\n3.  Визуализируйте различия с помощью boxplot или violin plot.\n\n**Рекомендации** :\n\n-   Для многомерных данных (например, одновременное сравнение длины, веса и возраста) применяйте MANOVA.\n\n-   Если группы неоднородны (например, разный возрастной состав), используйте ковариационный анализ (ANCOVA).\n\n    ### **Что делать, если тест на нормальность не пройден для одной из групп?**\n\n    При сравнении количественных характеристик (например, длины карапакса у самцов и самок) важно учитывать, соответствуют ли данные нормальному распределению. Если тест на нормальность (например, Шапиро-Уилка) показывает значимое отклонение от нормальности для одной из групп, это влияет на выбор статистического теста и интерпретацию результатов.\n\n    #### **Пример из нашего анализа**\n\n    Мы провели сравнение длины карапакса между самцами и самками:\n\n    -   Для самцов: **`shapiro_test(males$length)`** → p-value = **0.000574** (нормальность отвергнута).\n\n    -   Для самок: **`shapiro_test(females$length)`** → p-value = **0.891** (нормальность подтверждена).\n\n    Несмотря на это, мы применили как **t-тест** , так и **U-тест Манна-Уитни** :\n\n    -   **t-тест** : p-value = 1.46e-40 (значимо).\n\n    -   **U-тест** : p-value = 1.97e-27 (значимо).\n\n    -   Коэффициент Коэна: d = 2.14 (большой эффект).\n\n    #### **Почему это работает?**\n\n    1.  **t-тест устойчив к умеренным отклонениям от нормальности** :\n\n        -   При больших выборках (n \\> 30) центральная предельная теорема позволяет использовать t-тест даже при слабо выраженной асимметрии.\n\n        -   В вашем случае выборка самцов (n = 149) достаточно велика, чтобы компенсировать отклонение от нормальности.\n\n    2.  **U-тест Манна-Уитни — непараметрическая альтернатива** :\n\n        -   Этот тест не требует нормальности и сравнивает ранги, а не средние значения.\n\n        -   Он подтверждает значимость различий, что усиливает доверие к выводу.\n\n    3.  **Эффект размера (коэффициент Кобена)** :\n\n        -   d = 2.14 указывает на **большой эффект** , что важно для биологической интерпретации, даже если p-values значимы.\n\n### Сравнение параметров (линейные модели для оценки межгрупповых различий)\n\nДля сравнения параметров двух линейных моделей (например, скорости роста самцов и самок) используем следующий подход.\n\n```{r}\n#| output: false\n#| eval: false\n# Установка рабочей директории\nsetwd(\"C:/TEXTBOOK/\")\n\n# Загрузка библиотек\nlibrary(tidyverse)\nlibrary(ggplot2)\nlibrary(broom)\nlibrary(knitr)\n\n# Загрузка данных\ndata <- read_csv(\"shrimp_catch.csv\") %>%\n  filter(!id %in% c(10, 50))  # Удаление аномальных наблюдений\n\n# Фильтрация данных по полу\ndata_male <- data %>% filter(sex == \"M\")\ndata_female <- data %>% filter(sex == \"F\")\n\n# Построение моделей\nmodel_male <- lm(length ~ age, data = data_male)\nmodel_female <- lm(length ~ age, data = data_female)\n\nggplot(data, aes(age, length, color = sex)) +\n  geom_point(alpha = 0.5) +\n  geom_smooth(method = \"lm\", formula = y ~ x) +\n  scale_color_manual(values = c(\"#E7B800\", \"#00AFBB\")) +\n  labs(x = \"Возраст\", y = \"Длина (мм)\") +\n  theme_minimal()\n```\n\n![Рис. 1.15: Визуализация моделей](images/comparison_shrimp.PNG){fig-align=\"center\" width=\"60%\"}\n\n**Метод 1: Объединенная модель с взаимодействиями**\n\n```{r}\n#| output: false\n#| eval: false\n# Установка рабочей директории\njoint_model <- lm(length ~ age * sex, data = data)\nsummary(joint_model) %>% \n  broom::tidy() %>% \n  filter(term == \"age:sexM\") %>% \n  kable(caption = \"Проверка различия наклонов\", digits = 3)\n\n```\n\n```{r}\n#| output: false\n#| eval: false\nTable: Проверка различия наклонов\n\n|term     | estimate| std.error| statistic| p.value|\n|:--------|--------:|---------:|---------:|-------:|\n|age:sexM |     1.86|     0.459|     4.053|       0|\n> \n\n```\n\n**Интерпретация:**\\\nЗначимый коэффициент взаимодействия **`age:sexM`** (p \\< 0.05) указывает на статистически значимые различия в скорости роста между полами.\n\n**Метод 2: Тест Вальда**\n\n```{r}\n#| output: false\n#| eval: false\nlibrary(car)\ndelta_beta <- coef(model_male)[\"age\"] - coef(model_female)[\"age\"]\nse_diff <- sqrt(vcov(model_male)[\"age\",\"age\"] + vcov(model_female)[\"age\",\"age\"])\nz_score <- delta_beta / se_diff\np_value <- 2 * pnorm(-abs(z_score))\n\ncat(\"Разница коэффициентов:\", round(delta_beta, 3), \n    \"\\nZ-статистика:\", round(z_score, 3),\n    \"\\np-value:\", format.pval(p_value, digits = 2))\n\n\ncomparison_table <- data.frame(\n  Параметр = c(\"Скорость роста самцов\", \"Скорость роста самок\", \"Разница\"),\n  Значение = c(\n    round(coef(model_male)[\"age\"], 2),\n    round(coef(model_female)[\"age\"], 2),\n    round(delta_beta, 2)\n  ),\n  `p-value` = c(\n    format.pval(summary(model_male)$coefficients[\"age\",4], digits = 2),\n    format.pval(summary(model_female)$coefficients[\"age\",4], digits = 2),\n    format.pval(p_value, digits = 2)\n  )\n)\nkable(comparison_table, caption = \"Сравнение коэффициентов роста\")\n```\n\nВывод\n\n```{r}\n#| output: false\n#| eval: false\n: Сравнение коэффициентов роста\n\n|Параметр              | Значение|p.value |\n|:---------------------|--------:|:-------|\n|Скорость роста самцов |     5.95|<2e-16  |\n|Скорость роста самок  |     4.09|5.2e-13 |\n|Разница               |     1.86|0.00024 |\n> \n```\n\n**Интерпретация:**\\\nЗначимая *разница* (p \\< 0.05) указывает на статистически значимые различия в скорости роста между полами.\n\n### Сравнение моделей\n\nОдним из ключевых аспектов анализа биологических данных является определение формы зависимости между переменными. В данном разделе мы рассмотрим основы подбора модели зависимости между длиной и весом креветок. Начиная с простой линейной модели, мы постепенно перейдем к более сложным нелинейным моделям, чтобы продемонстрировать методику выбора наилучшей модели. Cравним три модели — линейную, полиномиальную и степенную — чтобы определить, какая из них наилучшим образом описывает данные. Цель анализа — найти математическую зависимость, которая:\n\n1.  Точно предсказывает вес креветки по её длине.\n\n2.  Имеет биологическую интерпретацию.\n\n3.  Минимизирует ошибку предсказания.\n\n#### Модели и их параметры\n\n1.  **Линейная**: $\\text{weight} = \\beta_0 + \\beta_1\\cdot\\text{length}$\n2.  **Полиномиальная 3-й степени**: $\\text{weight} = \\beta_0 + \\beta_1\\cdot\\text{length} + \\beta_2\\cdot\\text{length}^2 + \\beta_3\\cdot\\text{length}^3$\n3.  **Степенная**: $\\text{weight} = a\\cdot\\text{length}^b$\n\n#### Метрики\n\n-   **R²** - (коэффициент детерминации): чем ближе к 1, тем лучше модель объясняет данные.\n-   **AIC** -(информационный критерий Акаике): чем меньше значение, тем лучше модель с учётом её сложности.\n\n#### **Результаты**\n\n##### **1. Линейная модель**\n\n```{r}\n#| output: false\n#| eval: false\nCoefficients:\n             Estimate Std. Error t value Pr(>|t|)    \n(Intercept) -2.115      0.085     -24.86   <2e-16 ***\nlength       0.1665     0.0038    43.71    <2e-16 ***\n```\n\n-   **R² = 0.894**\n\n-   **AIC = 148.02**\n\n![Рис. 1.5: Линейная модель](images/linear_shrimp.PNG){fig-align=\"center\" width=\"60%\"}\n\n##### **2. Полиномиальная модель**\n\n```{r}\n#| output: false\n#| eval: false\nCoefficients:\n                 Estimate Std. Error t value Pr(>|t|)    \npoly(length,3)1  14.5038    0.2127    68.18   <2e-16 ***\npoly(length,3)2   3.7209    0.2127    17.49   <2e-16 ***\npoly(length,3)3   0.9526    0.2127     4.48  1.2e-05 ***\n```\n\n-   **R² = 0.957**\n\n-   **AIC = -52.80**\n\n![Рис. 1.5: Полиномиальная модель](images/poly_shrimp.PNG){fig-align=\"center\" width=\"60%\"}\n\n##### **3. Степенная модель**\n\n```{r}\n#| output: false\n#| eval: false\nParameters:\n   Estimate Std. Error t value Pr(>|t|)    \na 0.000157   0.000028    5.60  6.3e-08 ***\nb 2.920160   0.054102   53.98   <2e-16 ***\n```\n\n-   **R² = 0.955**\n\n-   **AIC = -48.43** ![Рис. 1.5: Степенная модель](images/power_shrimp.PNG){fig-align=\"center\" width=\"60%\"}\n\n#### **3. Сравнение моделей**\n\n| **Модель**     | **R²** | **AIC** |\n|:---------------|:-------|:--------|\n| Линейная       | 0.894  | 148.02  |\n| Полиномиальная | 0.957  | -52.80  |\n| Степенная      | 0.955  | -48.43  |\n\n**Выводы:**\n\n1.  **Полиномиальная модель** демонстрирует наилучшие показатели (максимальный R² и минимальный AIC).\n\n2.  **Степенная модель** близка по качеству, но её параметр *b*≈2.92 близок к биологически ожидаемому значению 3 (вес пропорционален объёму).\n\n3.  **Линейная модель** существенно уступает по точности.\n\n#### **4. Рекомендации**\n\n-   **Для прогнозирования** используйте полиномиальную модель, так как она минимизирует ошибку.\n\n-   **Для биологической интерпретации** предпочтительна степенная модель: weight∝length^2.92^.\n\n-   **Избегайте переобучения:** Полиномиальные модели высокой степени могут терять интерпретируемость.\n\n#### **5. Визуализация остатков**\n\nОстатки степенной модели распределены равномерно, что подтверждает её адекватность: ![Рис. 1.5: Остатки](images/residuals_shrimp.PNG){fig-align=\"center\" width=\"60%\"}\n\n#### **Заключение**\n\nДля анализа зависимости веса от длины северной креветки **рекомендуется**:\n\n1.  **Полиномиальная модель** — для задач, требующих максимальной точности.\n\n2.  **Степенная модель** — для интерпретации биологических закономерностей.\n\nСкрипт вышеописанных событий:\n\n```{r}\n#| output: false\n#| eval: false\n# Установка рабочей директории\nsetwd(\"C:/TEXTBOOK/\")\n\n# Загрузка библиотек\nlibrary(tidyverse)\nlibrary(ggplot2)\n\n# Загрузка данных\ndata <- read_csv(\"shrimp_catch.csv\") %>%\n  filter(!id %in% c(10, 50))  # Удаление аномальных наблюдений\n\n# Проверка структуры\nglimpse(data)\n\n# Линейная модель: вес ~ длина\nmodel_linear <- lm(weight ~ length, data = data)\nsummary(model_linear)\n\n# Визуализация\nggplot(data, aes(x = length, y = weight)) +\n  geom_point(color = \"steelblue\", alpha = 0.7) +\n  geom_smooth(method = \"lm\", color = \"#FC4E07\") +\n  labs(title = \"Линейная модель\", x = \"Длина (мм)\", y = \"Вес (г)\")\n\n\n# Полиномиальная модель: вес ~ длина + длина? + длина?\nmodel_poly <- lm(weight ~ poly(length, 3), data = data)\nsummary(model_poly)\n\n# Визуализация\nggplot(data, aes(x = length, y = weight)) +\n  geom_point(color = \"steelblue\", alpha = 0.7) +\n  geom_smooth(method = \"lm\", formula = y ~ poly(x, 3), color = \"#E7B800\") +\n  labs(title = \"Полиномиальная модель\", x = \"Длина (мм)\", y = \"Вес (г)\")\n\n\n# Степенная модель: вес ~ длина^k (k подбирается)\nmodel_power <- nls(weight ~ a * length^b, \n                   data = data, \n                   start = list(a = 0.001, b = 3))  # Начальные значения\nsummary(model_power)\n\n# Визуализация\ndata$pred_power <- predict(model_power)\nggplot(data, aes(x = length, y = weight)) +\n  geom_point(color = \"steelblue\", alpha = 0.7) +\n  geom_line(aes(y = pred_power), color = \"#00BA38\", linewidth = 1.2) +\n  labs(title = \"Степенная модель\", x = \"Длина (мм)\", y = \"Вес (г)\")\n\n# Расчет AIC\nAIC(model_linear, model_poly, model_power)\n\n# Расчет R?\nr2_linear <- summary(model_linear)$r.squared\nr2_poly <- summary(model_poly)$r.squared\nr2_power <- 1 - sum(residuals(model_power)^2) / sum((data$weight - mean(data$weight))^2)\n\n# Создание таблицы сравнения моделей\ncomparison_table <- data.frame(\n  Модель = c(\"Линейная\", \"Полиномиальная\", \"Степенная\"),\n  R_square = c(r2_linear, r2_poly, r2_power),\n  AIC = c(AIC(model_linear), AIC(model_poly), AIC(model_power))\n)\n\n# Вывод таблицы\nprint(comparison_table)\n\n# Остатки для степенной модели\ndata$residuals <- residuals(model_power)\n\nggplot(data, aes(x = length, y = residuals)) +\n  geom_point(color = \"#FC4E07\", alpha = 0.7) +\n  geom_hline(yintercept = 0, linetype = \"dashed\") +\n  labs(title = \"Остатки степенной модели\", x = \"Длина (мм)\", y = \"Ошибка\")\n```\n"},"formats":{"html":{"identifier":{"display-name":"HTML","target-format":"html","base-format":"html"},"execute":{"fig-width":7,"fig-height":5,"fig-format":"retina","fig-dpi":96,"df-print":"default","error":false,"eval":true,"cache":null,"freeze":false,"echo":true,"output":true,"warning":true,"include":true,"keep-md":false,"keep-ipynb":false,"ipynb":null,"enabled":null,"daemon":null,"daemon-restart":false,"debug":false,"ipynb-filters":[],"ipynb-shell-interactivity":null,"plotly-connected":true,"engine":"knitr"},"render":{"keep-tex":false,"keep-typ":false,"keep-source":false,"keep-hidden":false,"prefer-html":false,"output-divs":true,"output-ext":"html","fig-align":"default","fig-pos":null,"fig-env":null,"code-fold":"none","code-overflow":"scroll","code-link":false,"code-line-numbers":false,"code-tools":false,"tbl-colwidths":"auto","merge-includes":true,"inline-includes":false,"preserve-yaml":false,"latex-auto-mk":true,"latex-auto-install":true,"latex-clean":true,"latex-min-runs":1,"latex-max-runs":10,"latex-makeindex":"makeindex","latex-makeindex-opts":[],"latex-tlmgr-opts":[],"latex-input-paths":[],"latex-output-dir":null,"link-external-icon":false,"link-external-newwindow":false,"self-contained-math":false,"format-resources":[],"notebook-links":true},"pandoc":{"standalone":true,"wrap":"none","default-image-extension":"png","to":"html","output-file":"chapter 1.html"},"language":{"toc-title-document":"Table of contents","toc-title-website":"On this page","related-formats-title":"Other Formats","related-notebooks-title":"Notebooks","source-notebooks-prefix":"Source","other-links-title":"Other Links","code-links-title":"Code Links","launch-dev-container-title":"Launch Dev Container","launch-binder-title":"Launch Binder","article-notebook-label":"Article Notebook","notebook-preview-download":"Download Notebook","notebook-preview-download-src":"Download Source","notebook-preview-back":"Back to Article","manuscript-meca-bundle":"MECA Bundle","section-title-abstract":"Abstract","section-title-appendices":"Appendices","section-title-footnotes":"Footnotes","section-title-references":"References","section-title-reuse":"Reuse","section-title-copyright":"Copyright","section-title-citation":"Citation","appendix-attribution-cite-as":"For attribution, please cite this work as:","appendix-attribution-bibtex":"BibTeX citation:","appendix-view-license":"View License","title-block-author-single":"Author","title-block-author-plural":"Authors","title-block-affiliation-single":"Affiliation","title-block-affiliation-plural":"Affiliations","title-block-published":"Published","title-block-modified":"Modified","title-block-keywords":"Keywords","callout-tip-title":"Tip","callout-note-title":"Note","callout-warning-title":"Warning","callout-important-title":"Important","callout-caution-title":"Caution","code-summary":"Code","code-tools-menu-caption":"Code","code-tools-show-all-code":"Show All Code","code-tools-hide-all-code":"Hide All Code","code-tools-view-source":"View Source","code-tools-source-code":"Source Code","tools-share":"Share","tools-download":"Download","code-line":"Line","code-lines":"Lines","copy-button-tooltip":"Copy to Clipboard","copy-button-tooltip-success":"Copied!","repo-action-links-edit":"Edit this page","repo-action-links-source":"View source","repo-action-links-issue":"Report an issue","back-to-top":"Back to top","search-no-results-text":"No results","search-matching-documents-text":"matching documents","search-copy-link-title":"Copy link to search","search-hide-matches-text":"Hide additional matches","search-more-match-text":"more match in this document","search-more-matches-text":"more matches in this document","search-clear-button-title":"Clear","search-text-placeholder":"","search-detached-cancel-button-title":"Cancel","search-submit-button-title":"Submit","search-label":"Search","toggle-section":"Toggle section","toggle-sidebar":"Toggle sidebar navigation","toggle-dark-mode":"Toggle dark mode","toggle-reader-mode":"Toggle reader mode","toggle-navigation":"Toggle navigation","crossref-fig-title":"Figure","crossref-tbl-title":"Table","crossref-lst-title":"Listing","crossref-thm-title":"Theorem","crossref-lem-title":"Lemma","crossref-cor-title":"Corollary","crossref-prp-title":"Proposition","crossref-cnj-title":"Conjecture","crossref-def-title":"Definition","crossref-exm-title":"Example","crossref-exr-title":"Exercise","crossref-ch-prefix":"Chapter","crossref-apx-prefix":"Appendix","crossref-sec-prefix":"Section","crossref-eq-prefix":"Equation","crossref-lof-title":"List of Figures","crossref-lot-title":"List of Tables","crossref-lol-title":"List of Listings","environment-proof-title":"Proof","environment-remark-title":"Remark","environment-solution-title":"Solution","listing-page-order-by":"Order By","listing-page-order-by-default":"Default","listing-page-order-by-date-asc":"Oldest","listing-page-order-by-date-desc":"Newest","listing-page-order-by-number-desc":"High to Low","listing-page-order-by-number-asc":"Low to High","listing-page-field-date":"Date","listing-page-field-title":"Title","listing-page-field-description":"Description","listing-page-field-author":"Author","listing-page-field-filename":"File Name","listing-page-field-filemodified":"Modified","listing-page-field-subtitle":"Subtitle","listing-page-field-readingtime":"Reading Time","listing-page-field-wordcount":"Word Count","listing-page-field-categories":"Categories","listing-page-minutes-compact":"{0} min","listing-page-category-all":"All","listing-page-no-matches":"No matching items","listing-page-words":"{0} words","listing-page-filter":"Filter","draft":"Draft"},"metadata":{"lang":"en","fig-responsive":true,"quarto-version":"1.7.29","bibliography":["references.bib"],"editor":"visual","theme":["cosmo","brand"],"title":"Анализ и визуализация данных улова"},"extensions":{"book":{"multiFile":true}}},"pdf":{"identifier":{"display-name":"PDF","target-format":"pdf","base-format":"pdf"},"execute":{"fig-width":5.5,"fig-height":3.5,"fig-format":"pdf","fig-dpi":300,"df-print":"default","error":false,"eval":true,"cache":null,"freeze":false,"echo":true,"output":true,"warning":true,"include":true,"keep-md":false,"keep-ipynb":false,"ipynb":null,"enabled":null,"daemon":null,"daemon-restart":false,"debug":false,"ipynb-filters":[],"ipynb-shell-interactivity":null,"plotly-connected":true,"engine":"knitr"},"render":{"keep-tex":false,"keep-typ":false,"keep-source":false,"keep-hidden":false,"prefer-html":false,"output-divs":true,"output-ext":"pdf","fig-align":"default","fig-pos":null,"fig-env":null,"code-fold":"none","code-overflow":"scroll","code-link":false,"code-line-numbers":false,"code-tools":false,"tbl-colwidths":true,"merge-includes":true,"inline-includes":false,"preserve-yaml":false,"latex-auto-mk":true,"latex-auto-install":true,"latex-clean":true,"latex-min-runs":1,"latex-max-runs":10,"latex-makeindex":"makeindex","latex-makeindex-opts":[],"latex-tlmgr-opts":[],"latex-input-paths":[],"latex-output-dir":null,"link-external-icon":false,"link-external-newwindow":false,"self-contained-math":false,"format-resources":[]},"pandoc":{"pdf-engine":"xelatex","standalone":true,"variables":{"graphics":true,"tables":true},"default-image-extension":"pdf","to":"pdf","output-file":"chapter 1.pdf"},"language":{"toc-title-document":"Table of contents","toc-title-website":"On this page","related-formats-title":"Other Formats","related-notebooks-title":"Notebooks","source-notebooks-prefix":"Source","other-links-title":"Other Links","code-links-title":"Code Links","launch-dev-container-title":"Launch Dev Container","launch-binder-title":"Launch Binder","article-notebook-label":"Article Notebook","notebook-preview-download":"Download Notebook","notebook-preview-download-src":"Download Source","notebook-preview-back":"Back to Article","manuscript-meca-bundle":"MECA Bundle","section-title-abstract":"Abstract","section-title-appendices":"Appendices","section-title-footnotes":"Footnotes","section-title-references":"References","section-title-reuse":"Reuse","section-title-copyright":"Copyright","section-title-citation":"Citation","appendix-attribution-cite-as":"For attribution, please cite this work as:","appendix-attribution-bibtex":"BibTeX citation:","appendix-view-license":"View License","title-block-author-single":"Author","title-block-author-plural":"Authors","title-block-affiliation-single":"Affiliation","title-block-affiliation-plural":"Affiliations","title-block-published":"Published","title-block-modified":"Modified","title-block-keywords":"Keywords","callout-tip-title":"Tip","callout-note-title":"Note","callout-warning-title":"Warning","callout-important-title":"Important","callout-caution-title":"Caution","code-summary":"Code","code-tools-menu-caption":"Code","code-tools-show-all-code":"Show All Code","code-tools-hide-all-code":"Hide All Code","code-tools-view-source":"View Source","code-tools-source-code":"Source Code","tools-share":"Share","tools-download":"Download","code-line":"Line","code-lines":"Lines","copy-button-tooltip":"Copy to Clipboard","copy-button-tooltip-success":"Copied!","repo-action-links-edit":"Edit this page","repo-action-links-source":"View source","repo-action-links-issue":"Report an issue","back-to-top":"Back to top","search-no-results-text":"No results","search-matching-documents-text":"matching documents","search-copy-link-title":"Copy link to search","search-hide-matches-text":"Hide additional matches","search-more-match-text":"more match in this document","search-more-matches-text":"more matches in this document","search-clear-button-title":"Clear","search-text-placeholder":"","search-detached-cancel-button-title":"Cancel","search-submit-button-title":"Submit","search-label":"Search","toggle-section":"Toggle section","toggle-sidebar":"Toggle sidebar navigation","toggle-dark-mode":"Toggle dark mode","toggle-reader-mode":"Toggle reader mode","toggle-navigation":"Toggle navigation","crossref-fig-title":"Figure","crossref-tbl-title":"Table","crossref-lst-title":"Listing","crossref-thm-title":"Theorem","crossref-lem-title":"Lemma","crossref-cor-title":"Corollary","crossref-prp-title":"Proposition","crossref-cnj-title":"Conjecture","crossref-def-title":"Definition","crossref-exm-title":"Example","crossref-exr-title":"Exercise","crossref-ch-prefix":"Chapter","crossref-apx-prefix":"Appendix","crossref-sec-prefix":"Section","crossref-eq-prefix":"Equation","crossref-lof-title":"List of Figures","crossref-lot-title":"List of Tables","crossref-lol-title":"List of Listings","environment-proof-title":"Proof","environment-remark-title":"Remark","environment-solution-title":"Solution","listing-page-order-by":"Order By","listing-page-order-by-default":"Default","listing-page-order-by-date-asc":"Oldest","listing-page-order-by-date-desc":"Newest","listing-page-order-by-number-desc":"High to Low","listing-page-order-by-number-asc":"Low to High","listing-page-field-date":"Date","listing-page-field-title":"Title","listing-page-field-description":"Description","listing-page-field-author":"Author","listing-page-field-filename":"File Name","listing-page-field-filemodified":"Modified","listing-page-field-subtitle":"Subtitle","listing-page-field-readingtime":"Reading Time","listing-page-field-wordcount":"Word Count","listing-page-field-categories":"Categories","listing-page-minutes-compact":"{0} min","listing-page-category-all":"All","listing-page-no-matches":"No matching items","listing-page-words":"{0} words","listing-page-filter":"Filter","draft":"Draft"},"metadata":{"block-headings":true,"bibliography":["references.bib"],"editor":"visual","documentclass":"scrreprt","title":"Анализ и визуализация данных улова"},"extensions":{"book":{"selfContainedOutput":true}}}},"projectFormats":["html","pdf"]}